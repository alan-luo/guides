{"version":3,"sources":["webpack:///path---articles-clojure-clojure-vectors-24241bdc79b44fb99677.js","webpack:///./.cache/json/articles-clojure-clojure-vectors.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-vectors.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,0FACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,yxHACAC,aACAC,MAAA,oBACAC,OAAA,+FAIAC,aACAC,KAAA","file":"path---articles-clojure-clojure-vectors-24241bdc79b44fb99677.js","sourcesContent":["webpackJsonp([2025],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-vectors.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>A vector is perhaps the most simple type of collection in Clojure. You can think of it like an array in Javascript. Let's define a simple vector:</p>\\n<pre><code>(def a-vector [1 2 3 4 5])\\n;; Alternatively, use the vector function:\\n(def another-vector (vector 1 2 3 4 5))\\n;; You can use commas to separate items, since Clojure treats them as whitespace.\\n(def comma-vector [1, 2, 3, 4, 5])\\n</code></pre>\\n<p>You'll see that it uses square brackets, just like an array in JS. Since Clojure, like JS, is dynamically typed, vectors can hold elements of any type, including other vectors.</p>\\n<pre><code>(def mixed-type-vector [1 \\\"foo\\\" :bar [\\\"spam\\\" 22] #\\\"^baz$\\\"])\\n</code></pre>\\n<h2>Adding items to a vector</h2>\\n<p>You can append items to a vector using <code>conj</code>. You can also prepend to a list using <code>into</code>, but note that <code>into</code> is intended for merging two vectors, so both its arguments must be vectors, and using <code>into</code> is slower than using <code>conj</code>.</p>\\n<pre><code>(time (conj [1 2] 3))\\n; => \\\"Elapsed time: 0.032206 msecs\\\"\\n;    [1 2 3]\\n(time (into [1] [2 3]))\\n; => \\\"Elapsed time: 0.078499 msecs\\\"\\n;    [1 2 3]\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/wBSUEd\\\">IDEOne it!</a></p>\\n<h2>Retrieving items from a vector</h2>\\n<p>You can retrieve items from a vector using <code>get</code>. This is equivalent to using bracket notation to access items in an array in many imperative languages. Items in a vector are 0-indexed, counting from the left.</p>\\n<pre><code>var arr = [1, 2, 3, 4, 5];\\narr[0];\\n// => 1\\n</code></pre>\\n<p>In Clojure, this would be written like so:</p>\\n<pre><code>(def a-vector [1 2 3 4 5])\\n(get a-vector 0)\\n; => 1\\n</code></pre>\\n<p>You can also give <code>get</code> a default value, if you give it an index that isn't in the array.</p>\\n<pre><code>;; the list doesn't have 2147483647 elements, so it'll return a string instead.\\n(get a-vector 2147483646 \\\"sorry, not found!\\\")\\n; => \\\"sorry, not found!\\\"\\n</code></pre>\\n<h2>Converting other collections into vectors</h2>\\n<p>Non-vector data structures can be converted into vectors using the <code>vec</code> function. With hashmaps, this produces a 2D vector containing pairs of keys and values.</p>\\n<pre><code>(vec '(1 2 3 4 5))\\n; => [1 2 3 4 5]\\n(vec {:jack \\\"black\\\" :barry \\\"white\\\"})\\n; => [[:jack \\\"black\\\"] [:barry \\\"white\\\"]]\\n</code></pre>\\n<h2>When to use a vector?</h2>\\n<p>A vector should be used in almost all cases if you need a collection, because they have the shortest random-access times, which makes it easy to retrieve items from a vector. Note that vectors are ordered. If order doesn't matter, it may be better to use a set. Also note that vectors are designed for appending items; if you need to prepend items, you might want to use a list.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-lists-they-are-everything/18417\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-hashmaps/18414\\\">Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\"></a>|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-lists-they-are-everything/18417\\\">Lists</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-hashmaps/18414\\\">Hashmaps</a>|</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Clojure   Vectors\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure---vectors/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/clojure/clojure---vectors/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-clojure-clojure-vectors-24241bdc79b44fb99677.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>A vector is perhaps the most simple type of collection in Clojure. You can think of it like an array in Javascript. Let's define a simple vector:</p>\\n<pre><code>(def a-vector [1 2 3 4 5])\\n;; Alternatively, use the vector function:\\n(def another-vector (vector 1 2 3 4 5))\\n;; You can use commas to separate items, since Clojure treats them as whitespace.\\n(def comma-vector [1, 2, 3, 4, 5])\\n</code></pre>\\n<p>You'll see that it uses square brackets, just like an array in JS. Since Clojure, like JS, is dynamically typed, vectors can hold elements of any type, including other vectors.</p>\\n<pre><code>(def mixed-type-vector [1 \\\"foo\\\" :bar [\\\"spam\\\" 22] #\\\"^baz$\\\"])\\n</code></pre>\\n<h2>Adding items to a vector</h2>\\n<p>You can append items to a vector using <code>conj</code>. You can also prepend to a list using <code>into</code>, but note that <code>into</code> is intended for merging two vectors, so both its arguments must be vectors, and using <code>into</code> is slower than using <code>conj</code>.</p>\\n<pre><code>(time (conj [1 2] 3))\\n; => \\\"Elapsed time: 0.032206 msecs\\\"\\n;    [1 2 3]\\n(time (into [1] [2 3]))\\n; => \\\"Elapsed time: 0.078499 msecs\\\"\\n;    [1 2 3]\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/wBSUEd\\\">IDEOne it!</a></p>\\n<h2>Retrieving items from a vector</h2>\\n<p>You can retrieve items from a vector using <code>get</code>. This is equivalent to using bracket notation to access items in an array in many imperative languages. Items in a vector are 0-indexed, counting from the left.</p>\\n<pre><code>var arr = [1, 2, 3, 4, 5];\\narr[0];\\n// => 1\\n</code></pre>\\n<p>In Clojure, this would be written like so:</p>\\n<pre><code>(def a-vector [1 2 3 4 5])\\n(get a-vector 0)\\n; => 1\\n</code></pre>\\n<p>You can also give <code>get</code> a default value, if you give it an index that isn't in the array.</p>\\n<pre><code>;; the list doesn't have 2147483647 elements, so it'll return a string instead.\\n(get a-vector 2147483646 \\\"sorry, not found!\\\")\\n; => \\\"sorry, not found!\\\"\\n</code></pre>\\n<h2>Converting other collections into vectors</h2>\\n<p>Non-vector data structures can be converted into vectors using the <code>vec</code> function. With hashmaps, this produces a 2D vector containing pairs of keys and values.</p>\\n<pre><code>(vec '(1 2 3 4 5))\\n; => [1 2 3 4 5]\\n(vec {:jack \\\"black\\\" :barry \\\"white\\\"})\\n; => [[:jack \\\"black\\\"] [:barry \\\"white\\\"]]\\n</code></pre>\\n<h2>When to use a vector?</h2>\\n<p>A vector should be used in almost all cases if you need a collection, because they have the shortest random-access times, which makes it easy to retrieve items from a vector. Note that vectors are ordered. If order doesn't matter, it may be better to use a set. Also note that vectors are designed for appending items; if you need to prepend items, you might want to use a list.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-lists-they-are-everything/18417\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-hashmaps/18414\\\">Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\"></a>|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-lists-they-are-everything/18417\\\">Lists</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-hashmaps/18414\\\">Hashmaps</a>|</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Clojure   Vectors\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure---vectors/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/clojure/clojure---vectors/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-clojure-clojure-vectors.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-vectors.json\n// module chunks = 2025"],"sourceRoot":""}