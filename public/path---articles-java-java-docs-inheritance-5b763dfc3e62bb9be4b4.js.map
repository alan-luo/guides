{"version":3,"sources":["webpack:///path---articles-java-java-docs-inheritance-5b763dfc3e62bb9be4b4.js","webpack:///./.cache/json/articles-java-java-docs-inheritance.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-inheritance.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,6FACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,s1RACAC,aACAC,MAAA,wBACAC,OAAA,gGAIAC,aACAC,KAAA","file":"path---articles-java-java-docs-inheritance-5b763dfc3e62bb9be4b4.js","sourcesContent":["webpackJsonp([1558],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-inheritance.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<h1>Java Inheritance</h1>\\n<p>Java inheritance refers to the ability of a Java Class to <code>inherit</code> the properties from some other Class. Think of it like a child inheriting properties from its parents, the concept is very similar to that. In Java lingo, it is also called <em>extend</em>-ing a class. Some simple things to remember :</p>\\n<ul>\\n<li>The Class that extends or inherits is called <strong>subclass</strong></li>\\n<li>The Class that is being extended or inherited is called <strong>superclass</strong></li>\\n</ul>\\n<p>Thus, inheritance gives Java the cool capability of <em>re-using</em> code, or share code between classes!</p>\\n<p>Let's describe it with the classic example of a <code>Vehicle</code> class and a <code>Car</code> class :</p>\\n<pre><code>public class Vehicle {\\n    public void start() {\\n        // starting the engine\\n    }\\n\\n    public void stop() {\\n        // stopping the engine\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    int numberOfSeats = 4;\\n\\n    public int getNumberOfSeats() {\\n        return numberOfSeats;\\n    }\\n}\\n</code></pre>\\n<p>Here we can see the <code>Car</code> class inheriting the properties of the <code>Vehicle</code> class. So, we dont have to write the same code of <code>start()</code> and <code>stop()</code> for <code>Car</code> as well, as those properties come from its parent. Yes, objects created from the <code>Car</code> class <em>also</em> have those properties!</p>\\n<pre><code>Car tesla = new Car();\\n\\ntesla.start();\\n\\ntesla.stop();\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJXz/0\\\">Run Code</a></p>\\n<p>But, does the parent Class has the methods of the child? No, it doesn't.</p>\\n<p>Therefore, whenever you need to share some common bit of code to some more classes, it is always good to have a parent Class, and then extend that Class whenever needed! Saves a lot of lines of code, makes code modular and better testable.</p>\\n<h2>What can be inherited ?</h2>\\n<ul>\\n<li>All <code>protected</code> and <code>public</code> fields and methods from parent</li>\\n</ul>\\n<h2>What cannot be inherited ?</h2>\\n<ul>\\n<li><code>private</code> fields and methods</li>\\n<li>Constructors. Although, subclass constructor <em>has</em> to call superclass constructor if its defined (More on that later!)</li>\\n<li>Multiple classes. Java supports only <strong>single inheritance</strong>, that is you can only inherit one class at a time.</li>\\n<li>Fields. Individual fields of a class cannot be overriden by the subclass.</li>\\n</ul>\\n<h2>Type Casting &#x26; Reference</h2>\\n<p>In Java, it is possible to reference a subclass as an <em>instance</em> of its superclass. It is called <em>Polymorphism</em> in Object Oriented Programming, the ability of an object to take on many forms. For example, <code>Car</code> class object can be referenced as a <code>Vehicle</code> class instance like this :</p>\\n<pre><code>Vehicle car = new Car();\\n</code></pre>\\n<p>Although, the opposite is not possible :</p>\\n<pre><code>Car car = new Vehicle(); // ERROR\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYB/0\\\">Run Code</a></p>\\n<p>Since you can reference a Java subclass as a superclass instance, you can cast a subclass object easily to a superclass instance. It may be possible to cast a superclass object into a subclass type, but <em>only if the object is really an instance of subclass</em>. So keep this in mind :</p>\\n<pre><code>Car car = new Car();\\nVehicle vehicle = car; // upcasting\\nCar car2 = (Car)vechile; //downcasting\\n\\nBike bike = new Bike(); // say Bike is also a subclass of Vehicle\\nVehicle v = bike; // upcasting, no problem here.\\nCar car3 = (Car)bike; // Compilation Error : as bike is NOT a instance of Car\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYM/0\\\">Run Code</a></p>\\n<p>Now you know how to share code through parent-child relationship. But, what if, you do not like the implementation of a particular method in the child class and want to write a new one for it? What to do then?</p>\\n<h2>Override it!</h2>\\n<p>Java lets you <em>override</em> or redefine the methods defined in the superclass. For example, your <code>Car</code> class has a different implementation of <code>start()</code> than the parent <code>Vehicle</code>, so you do this :</p>\\n<pre><code>public class Vehicle {\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public void start() {\\n      System.out.println(\\\"Car start code\\\");\\n  }\\n}\\n\\nCar car = new Car();\\ncar.start(); // \\\"Car start code\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYZ/1\\\">Run Code</a></p>\\n<p>So, it's pretty simple to override methods in the subclass. Although, there is a <em>catch</em>. Only that superclass method will be overriden which has the <em>exact same method signature</em> as the subclass method. That means the subclass method definition must have the exact same name, same number and type of parameters, and in the exact same sequence. Thus, <code>public void start(String key)</code> would not override <code>public void start()</code>.</p>\\n<p><strong>Notes</strong> :</p>\\n<ul>\\n<li>You cannot override private methods of the superclass. (Quite obvious, isn't it?)</li>\\n<li>What if the method of superclass which you are overriding in the subclass suddenly gets obliterated or methods changed? It would fail in runtime! So Java provides you a nifty annotation <code>@Override</code> which you can place over the subclass method, which will warn the compiler of those incidents!</li>\\n</ul>\\n<p>Annotations in Java is a good coding practice, but they are not a necessity. The compiler is smart enough to figure out overriding on its own though. Unlike other OOP languages, Annotations in Java it doesn't necessarily modify the method or add extra functionality.</p>\\n<h2>How to call super class methods?</h2>\\n<p>Funny you ask about it! Just use the keyword <code>super</code> :</p>\\n<pre><code>public class Vehicle() {\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public void run() {\\n      super.start();\\n  }\\n}\\n\\nCar car = new Car();\\ncar.run(); // \\\"Vehicle start code\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJY4/0\\\">Run Code</a></p>\\n<p><strong>N.B.</strong> : Although you can call the parent method by <code>super</code> call, you cannot go up the inheritance with chained <code>super</code> calls.</p>\\n<h2>How to know the type of a class?</h2>\\n<p>Using the <code>instanceof</code> keyword. Having lots of classes and subclasses it would be a little confusing to know which class is a subclass of which one in runtime. So, we can use <code>instanceof</code> to determine whether a class is actually a subclass of a superclass or not.</p>\\n<pre><code>Car car = new Car();\\n\\nboolean flag = car instanceof Vehicle; // true in this case!\\n</code></pre>\\n<h2>Constructors &#x26; Inheritance</h2>\\n<p>As mentioned earlier, constructors cannot be directly inherited by a subclass. Although, a subclass is <em>required</em> to call its parent's constructor as the <a href=\\\"http://stackoverflow.com/questions/1168345/why-does-this-and-super-have-to-be-the-first-statement-in-a-constructor\\\">first thing</a> in its own constructor. How? You guessed it, using <code>super</code> :</p>\\n<pre><code>public class Vehicle {\\n    public Vehicle() {\\n        // constructor\\n    }\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public Car() {\\n      super();\\n    }\\n    public void run() {\\n      super.start();\\n  }\\n}\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJY8/0\\\">Run Code</a></p>\\n<p>Remember, if the superclass does not have any constructors defined, you dont have to call it explicitely in the subclass. Java handles that internally for you! Invocation to <code>super</code> constructor is done in the case when the super class is to be called with any other constructor other than the <em>default constructor</em>.</p>\\n<p>If no other constructors are defined, then Java invokes the default super class constructor (<em>even if not defined explicitly</em>).</p>\\n<p>Congrats, now you know all about Inheritance! Read more about advanced ways to inherit things in Abstract Classes and <a href=\\\"//forum.freecodecamp.com/t/java-docs-interfaces\\\">Interfaces</a>!</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Java Docs Inheritance\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/java/java-docs-inheritance/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/java/java-docs-inheritance/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-java-java-docs-inheritance-5b763dfc3e62bb9be4b4.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<h1>Java Inheritance</h1>\\n<p>Java inheritance refers to the ability of a Java Class to <code>inherit</code> the properties from some other Class. Think of it like a child inheriting properties from its parents, the concept is very similar to that. In Java lingo, it is also called <em>extend</em>-ing a class. Some simple things to remember :</p>\\n<ul>\\n<li>The Class that extends or inherits is called <strong>subclass</strong></li>\\n<li>The Class that is being extended or inherited is called <strong>superclass</strong></li>\\n</ul>\\n<p>Thus, inheritance gives Java the cool capability of <em>re-using</em> code, or share code between classes!</p>\\n<p>Let's describe it with the classic example of a <code>Vehicle</code> class and a <code>Car</code> class :</p>\\n<pre><code>public class Vehicle {\\n    public void start() {\\n        // starting the engine\\n    }\\n\\n    public void stop() {\\n        // stopping the engine\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    int numberOfSeats = 4;\\n\\n    public int getNumberOfSeats() {\\n        return numberOfSeats;\\n    }\\n}\\n</code></pre>\\n<p>Here we can see the <code>Car</code> class inheriting the properties of the <code>Vehicle</code> class. So, we dont have to write the same code of <code>start()</code> and <code>stop()</code> for <code>Car</code> as well, as those properties come from its parent. Yes, objects created from the <code>Car</code> class <em>also</em> have those properties!</p>\\n<pre><code>Car tesla = new Car();\\n\\ntesla.start();\\n\\ntesla.stop();\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJXz/0\\\">Run Code</a></p>\\n<p>But, does the parent Class has the methods of the child? No, it doesn't.</p>\\n<p>Therefore, whenever you need to share some common bit of code to some more classes, it is always good to have a parent Class, and then extend that Class whenever needed! Saves a lot of lines of code, makes code modular and better testable.</p>\\n<h2>What can be inherited ?</h2>\\n<ul>\\n<li>All <code>protected</code> and <code>public</code> fields and methods from parent</li>\\n</ul>\\n<h2>What cannot be inherited ?</h2>\\n<ul>\\n<li><code>private</code> fields and methods</li>\\n<li>Constructors. Although, subclass constructor <em>has</em> to call superclass constructor if its defined (More on that later!)</li>\\n<li>Multiple classes. Java supports only <strong>single inheritance</strong>, that is you can only inherit one class at a time.</li>\\n<li>Fields. Individual fields of a class cannot be overriden by the subclass.</li>\\n</ul>\\n<h2>Type Casting &#x26; Reference</h2>\\n<p>In Java, it is possible to reference a subclass as an <em>instance</em> of its superclass. It is called <em>Polymorphism</em> in Object Oriented Programming, the ability of an object to take on many forms. For example, <code>Car</code> class object can be referenced as a <code>Vehicle</code> class instance like this :</p>\\n<pre><code>Vehicle car = new Car();\\n</code></pre>\\n<p>Although, the opposite is not possible :</p>\\n<pre><code>Car car = new Vehicle(); // ERROR\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYB/0\\\">Run Code</a></p>\\n<p>Since you can reference a Java subclass as a superclass instance, you can cast a subclass object easily to a superclass instance. It may be possible to cast a superclass object into a subclass type, but <em>only if the object is really an instance of subclass</em>. So keep this in mind :</p>\\n<pre><code>Car car = new Car();\\nVehicle vehicle = car; // upcasting\\nCar car2 = (Car)vechile; //downcasting\\n\\nBike bike = new Bike(); // say Bike is also a subclass of Vehicle\\nVehicle v = bike; // upcasting, no problem here.\\nCar car3 = (Car)bike; // Compilation Error : as bike is NOT a instance of Car\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYM/0\\\">Run Code</a></p>\\n<p>Now you know how to share code through parent-child relationship. But, what if, you do not like the implementation of a particular method in the child class and want to write a new one for it? What to do then?</p>\\n<h2>Override it!</h2>\\n<p>Java lets you <em>override</em> or redefine the methods defined in the superclass. For example, your <code>Car</code> class has a different implementation of <code>start()</code> than the parent <code>Vehicle</code>, so you do this :</p>\\n<pre><code>public class Vehicle {\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public void start() {\\n      System.out.println(\\\"Car start code\\\");\\n  }\\n}\\n\\nCar car = new Car();\\ncar.start(); // \\\"Car start code\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJYZ/1\\\">Run Code</a></p>\\n<p>So, it's pretty simple to override methods in the subclass. Although, there is a <em>catch</em>. Only that superclass method will be overriden which has the <em>exact same method signature</em> as the subclass method. That means the subclass method definition must have the exact same name, same number and type of parameters, and in the exact same sequence. Thus, <code>public void start(String key)</code> would not override <code>public void start()</code>.</p>\\n<p><strong>Notes</strong> :</p>\\n<ul>\\n<li>You cannot override private methods of the superclass. (Quite obvious, isn't it?)</li>\\n<li>What if the method of superclass which you are overriding in the subclass suddenly gets obliterated or methods changed? It would fail in runtime! So Java provides you a nifty annotation <code>@Override</code> which you can place over the subclass method, which will warn the compiler of those incidents!</li>\\n</ul>\\n<p>Annotations in Java is a good coding practice, but they are not a necessity. The compiler is smart enough to figure out overriding on its own though. Unlike other OOP languages, Annotations in Java it doesn't necessarily modify the method or add extra functionality.</p>\\n<h2>How to call super class methods?</h2>\\n<p>Funny you ask about it! Just use the keyword <code>super</code> :</p>\\n<pre><code>public class Vehicle() {\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public void run() {\\n      super.start();\\n  }\\n}\\n\\nCar car = new Car();\\ncar.run(); // \\\"Vehicle start code\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJY4/0\\\">Run Code</a></p>\\n<p><strong>N.B.</strong> : Although you can call the parent method by <code>super</code> call, you cannot go up the inheritance with chained <code>super</code> calls.</p>\\n<h2>How to know the type of a class?</h2>\\n<p>Using the <code>instanceof</code> keyword. Having lots of classes and subclasses it would be a little confusing to know which class is a subclass of which one in runtime. So, we can use <code>instanceof</code> to determine whether a class is actually a subclass of a superclass or not.</p>\\n<pre><code>Car car = new Car();\\n\\nboolean flag = car instanceof Vehicle; // true in this case!\\n</code></pre>\\n<h2>Constructors &#x26; Inheritance</h2>\\n<p>As mentioned earlier, constructors cannot be directly inherited by a subclass. Although, a subclass is <em>required</em> to call its parent's constructor as the <a href=\\\"http://stackoverflow.com/questions/1168345/why-does-this-and-super-have-to-be-the-first-statement-in-a-constructor\\\">first thing</a> in its own constructor. How? You guessed it, using <code>super</code> :</p>\\n<pre><code>public class Vehicle {\\n    public Vehicle() {\\n        // constructor\\n    }\\n    public void start() {\\n      System.out.println(\\\"Vehicle start code\\\");\\n    }\\n}\\n\\npublic class Car extends Vehicle {\\n    public Car() {\\n      super();\\n    }\\n    public void run() {\\n      super.start();\\n  }\\n}\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CJY8/0\\\">Run Code</a></p>\\n<p>Remember, if the superclass does not have any constructors defined, you dont have to call it explicitely in the subclass. Java handles that internally for you! Invocation to <code>super</code> constructor is done in the case when the super class is to be called with any other constructor other than the <em>default constructor</em>.</p>\\n<p>If no other constructors are defined, then Java invokes the default super class constructor (<em>even if not defined explicitly</em>).</p>\\n<p>Congrats, now you know all about Inheritance! Read more about advanced ways to inherit things in Abstract Classes and <a href=\\\"//forum.freecodecamp.com/t/java-docs-interfaces\\\">Interfaces</a>!</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Java Docs Inheritance\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/java/java-docs-inheritance/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/java/java-docs-inheritance/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-java-java-docs-inheritance.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-inheritance.json\n// module chunks = 1558"],"sourceRoot":""}