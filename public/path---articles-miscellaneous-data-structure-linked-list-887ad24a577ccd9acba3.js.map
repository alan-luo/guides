{"version":3,"sources":["webpack:///path---articles-miscellaneous-data-structure-linked-list-887ad24a577ccd9acba3.js","webpack:///./.cache/json/articles-miscellaneous-data-structure-linked-list.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-linked-list.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,MAERC,2GACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,+0WACAC,aACAC,MAAA,6BACAC,OAAA,8GAIAC,aACAC,KAAA","file":"path---articles-miscellaneous-data-structure-linked-list-887ad24a577ccd9acba3.js","sourcesContent":["webpackJsonp([410],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-linked-list.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>Just like a garland is made with flowers, a linked list is made up of nodes. We call every flower on this particular garland to be a node. And each of the node points to the next node in this list as well as it has data (here it is type of flower).</p>\\n<h2>Types</h2>\\n<ol>\\n<li>Singly Linked List</li>\\n</ol>\\n<p>Singly linked lists contain nodes which have a <code>data</code> field as well as a <code>next</code> field, which points to the next node in the sequence. Operations that can be performed on singly linked lists are insertion, deletion and traversal.</p>\\n<p>`</p>\\n<pre><code>Singly Link List\\n</code></pre>\\n<hr>\\n<pre><code>   head\\n    |\\n    |\\n  +-----+--+      +-----+--+      +-----+------+\\n  |  1  |o----->  |  2  |o----->  |  3  | NULL |\\n  +-----+--+      +-----+--+      +-----+------+\\n</code></pre>\\n<p>`</p>\\n<p>Application</p>\\n<p>Internal implementation of CPython, the frames and evaluated variables are kept on a stack.</p>\\n<p>For this we need to iterate only forward aur get the head, therefore singly linked-list is used.</p>\\n<ol>\\n<li>Doubly Linked List</li>\\n</ol>\\n<p>Doubly linked lists contain node which have <code>data</code> field, <code>next</code> field and another link field <code>prev</code> pointing to the previous node in the sequence.</p>\\n<p>`</p>\\n<p>Doubly Linked List</p>\\n<hr>\\n<pre><code>          head\\n           |\\n           |\\n  +------+-----+--+    +--+-----+--+       +-----+------+\\n  |      |     |o------>  |     |o------>  |     |      |\\n  | NULL |  1  |          |  2  |          |  3  | NULL |\\n  |      |     |  &#x3C;------o|     |  &#x3C;------o|     |      |\\n  +------+-----+--+    +--+-----+--+       +-----+------+\\n</code></pre>\\n<p>`</p>\\n<p>Application</p>\\n<p>The browser cache which allows you to hit the BACK and FORWARD button. Here we need to maintain a doubly linked list, with <code>URLs</code> as data field, to allow access in both direction. To go to previous URL we will use <code>prev</code> field and to go to next page we will use <code>next</code> field.</p>\\n<ol>\\n<li>Circular Linked List</li>\\n</ol>\\n<p>Circular linked lists is a singly linked list in which last node, <code>next</code> field points to first node in the sequence.</p>\\n<p>`</p>\\n<p>Circular Linked List</p>\\n<hr>\\n<pre><code>     head\\n      |\\n      |\\n    +-----+--+      +-----+--+      +-----+--+\\n</code></pre>\\n<p>--> | 1 |o-----> | 2 |o-----> | 3 |o----<br>\\n| +-----+--+ +-----+--+ +-----+--+ |<br>\\n| |</p>\\n<hr>\\n<p>`</p>\\n<p><strong>Application</strong></p>\\n<p>Timesharing problem solved by the operating system.</p>\\n<p>In a timesharing environment, the operating system must maintain a list of present users and must alternately allow each user to use a small portion of CPU time, one user at a time. The operating system will pick a user, let him/her use a small amount of CPU time and then move on to the next user.</p>\\n<p>For this application, there should be no NULL pointers unless there is absolutely no one requesting CPU time, i.e list is empty.</p>\\n<h2>Basic Operations</h2>\\n<ol>\\n<li>Insertion</li>\\n</ol>\\n<p>To add a new element to the list.</p>\\n<p>`</p>\\n<p>Insertion at the beginning</p>\\n<hr>\\n<ul>\\n<li>Create a new node with given data.</li>\\n<li>Point new node's <code>next</code> to old <code>head</code>.</li>\\n<li>Point <code>head</code> to this new node.</li>\\n</ul>\\n<p>Insertion in the middle/end</p>\\n<hr>\\n<p>Insertion after node X.</p>\\n<ul>\\n<li>Create a new node with given data.</li>\\n<li>Point new node's <code>next</code> to old X's <code>next</code>.</li>\\n<li>Point X's <code>next</code> to this new node.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(1)</strong></p>\\n<ol>\\n<li>Deletion</li>\\n</ol>\\n<p>To delete existing element from the list.</p>\\n<p>`</p>\\n<p>Deletion at the beginning</p>\\n<hr>\\n<ul>\\n<li>Get the node pointed by <code>head</code> as Temp.</li>\\n<li>Point <code>head</code> to Temp's <code>next</code>.</li>\\n<li>Free memory used by Temp node.</li>\\n</ul>\\n<p>Deletion in the middle/end</p>\\n<hr>\\n<p>Deletion after node X.</p>\\n<ul>\\n<li>Get the node pointed by <code>X</code> as Temp.</li>\\n<li>Point X's <code>next</code> to Temp's <code>next</code>.</li>\\n<li>Free memory used by Temp node.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(1)</strong></p>\\n<ol>\\n<li>Traversing</li>\\n</ol>\\n<p>To travel across the list.</p>\\n<p>`</p>\\n<p>Traversal</p>\\n<hr>\\n<ul>\\n<li>Get the node pointed by <code>head</code> as Current.</li>\\n<li>Check if Current is not null and display it.</li>\\n<li>Point Current to Current's <code>next</code> and move to above step.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(n) // Here n is size of link-list</strong></p>\\n<h2>Implementation</h2>\\n<h3>C++ implementation of singly linked list</h3>\\n<pre><code>// Header files\\n#include &#x3C;iostream>\\n\\nstruct node\\n{\\n    int data;\\n    struct node *next;\\n};\\n\\n// Head pointer always points to first element of the linked list\\nstruct node *head = NULL;\\n</code></pre>\\n<h4>Printing data in each node</h4>\\n<pre><code>// Display the list\\nvoid printList()\\n{\\n    struct node *ptr = head;\\n\\n    // Start from the beginning\\nwhile(ptr != NULL)\\n{\\n    std::cout &#x3C;&#x3C; ptr->data &#x3C;&#x3C; \\\" \\\";\\n    ptr = ptr->next;\\n}\\n\\nstd::cout &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Insertion at the beginning</h4>\\n<pre><code>// Insert link at the beginning\\nvoid insertFirst(int data)\\n{\\n    // Create a new node\\n    struct node *new_node = new struct node;\\n\\n    new_node->data = data;\\n\\n// Point it to old head\\nnew_node->next = head;\\n\\n// Point head to new node\\nhead = new_node;\\n\\nstd::cout &#x3C;&#x3C; \\\"Inserted successfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Deletion at the beginning</h4>\\n<pre><code>// Delete first item\\nvoid deleteFirst()\\n{\\n    // Save reference to head\\n    struct node *temp = head;\\n\\n    // Point head to head's next\\nhead = head->next;\\n\\n// Free memory used by temp\\ntemp = NULL:\\ndelete temp;\\n\\nstd::cout &#x3C;&#x3C; \\\"Deleted successfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Size</h4>\\n<pre><code>// Find no. of nodes in link list\\nvoid size()\\n{\\n    int length = 0;\\n    struct node *current;\\n\\n    for(current = head; current != NULL; current = current->next)\\n{\\n    length++;\\n}\\n\\nstd::cout &#x3C;&#x3C; \\\"Size of Linked List is \\\" &#x3C;&#x3C; length &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Searching</h4>\\n<pre><code>// Find node with given data\\nvoid find(int data){\\n\\n    // Start from the head\\nstruct node* current = head;\\n\\n// If list is empty\\nif(head == NULL)\\n{\\n    std::cout &#x3C;&#x3C; \\\"List is empty\\\" &#x3C;&#x3C; std::endl;\\n    return;\\n}\\n\\n// Traverse through list\\nwhile(current->data != data){\\n\\n    // If it is last node\\n    if(current->next == NULL){\\n        std::cout &#x3C;&#x3C; \\\"Not Found\\\" &#x3C;&#x3C; std::endl;\\n        return;\\n    }\\n    else{\\n        // Go to next node\\n        current = current->next;\\n    }\\n}\\n\\n// If data found\\nstd::cout &#x3C;&#x3C; \\\"Found\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Deletion after a node</h4>\\n<pre><code>// Delete a node with given data\\nvoid del(int data){\\n\\n    // Start from the first node\\nstruct node* current = head;\\nstruct node* previous = NULL;\\n\\n// If list is empty\\nif(head == NULL){\\n    std::cout &#x3C;&#x3C; \\\"List is empty\\\" &#x3C;&#x3C; std::endl;\\n    return ;\\n}\\n\\n// Navigate through list\\nwhile(current->data != data){\\n\\n    // If it is last node\\n    if(current->next == NULL){\\n        std::cout &#x3C;&#x3C; \\\"Element not found\\\" &#x3C;&#x3C; std::endl;\\n        return ;\\n    }\\n    else {\\n        // Store reference to current node\\n        previous = current;\\n        // Move to next node\\n        current = current->next;\\n    }\\n\\n}\\n\\n// Found a match, update the node\\nif(current == head) {\\n    // Change head to point to next node\\n    head = head->next;\\n}\\nelse {\\n    // Skip the current node\\n    previous->next = current->next;\\n}\\n\\n// Free space used by deleted node\\ncurrent = NULL;\\ndelete current;\\nstd::cout &#x3C;&#x3C; \\\"Deleted succesfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<p>:rocket: <a href=\\\"https://repl.it/CXVt/1\\\">Run Code</a> ### Python Implementation of Singly Linked List  </p>\\n<pre><code>class Node(object):\\n    # Constructor\\n    def __init__(self, data=None, next=None):\\n        self.data = data\\n        self.next = next\\n\\n    # Function to get data\\ndef get_data(self):\\n    return self.data\\n\\n# Function to get next node\\ndef get_next(self):\\n    return self.next\\n\\n# Function to set next field\\ndef set_next(self, new_next):\\n    self.next = new_next\\nclass LinkedList(object):\\n    def __init__(self, head=None):\\n        self.head = head\\n</code></pre>\\n<h4>Insertion</h4>\\n<pre><code>    # Function to insert data\\ndef insert(self, data):\\n    # new_node is a object of class Node\\n    new_node = Node(data)\\n    new_node.set_next(self.head)\\n    self.head = new_node\\n    print(\\\"Node with data \\\" + str(data) + \\\" is created succesfully\\\")\\n</code></pre>\\n<h4>Size</h4>\\n<pre><code>    # Function to get size\\ndef size(self):\\n    current = self.head\\n    count = 0\\n    while current:\\n        count += 1\\n        current = current.get_next()\\n    print(\\\"Size of link list is \\\" + str(count))\\n</code></pre>\\n<h4>Searching</h4>\\n<pre><code>    # Function to search a data\\ndef search(self, data):\\n    current = self.head\\n    found = False\\n    while current and found is False:\\n        if current.get_data() == data:\\n            found = True\\n        else:\\n            current = current.get_next()\\n    if current is None:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is not present\\\")\\n    else:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is found\\\")\\n</code></pre>\\n<h4>Deletion after a node</h4>\\n<pre><code>    # Function to delete a node with data\\ndef delete(self, data):\\n    current = self.head\\n    previous = None\\n    found = False\\n    while current and found is False:\\n        if current.get_data() == data:\\n            found = True\\n        else:\\n            previous = current\\n            current = current.get_next()\\n    if current is None:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is not in list\\\")\\n    elif previous is None:\\n        self.head = current.get_next()\\n        print(\\\"Node with data \\\" + str(data) + \\\" is deleted successfully\\\")\\n    else:\\n        previous.set_next(current.get_next())\\n        print(\\\"Node with data \\\" + str(data) + \\\" is deleted successfully\\\")\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CVq3/2\\\">Run Code</a></p>\\n<p><strong>Advantages</strong></p>\\n<ol>\\n<li>Linked lists are a dynamic data structure, which can grow and shrink, allocating and deallocating memory while the program is running.</li>\\n<li>Insertion and deletion of node are easily implemented in a linked list at any position.</li>\\n</ol>\\n<p><strong>Disadvantages</strong></p>\\n<ol>\\n<li>They use more memory than arrays because of the memory used by their pointers (<code>next</code> and <code>prev</code>).</li>\\n<li>Random access is not possible in linked list. We have to access nodes sequentially.</li>\\n<li>It's more complex than array. If a language supports array bound check automatically, Arrays would serve you better.</li>\\n</ol>\\n<h4>Note</h4>\\n<p>We have to use free() in C and delete in C++ to free the space used by deleted node, whereas, in Python and Java free space is collected automatically by garbage collector.</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Data Structure Linked List\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/data-structure-linked-list/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/miscellaneous/data-structure-linked-list/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-miscellaneous-data-structure-linked-list-887ad24a577ccd9acba3.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>Just like a garland is made with flowers, a linked list is made up of nodes. We call every flower on this particular garland to be a node. And each of the node points to the next node in this list as well as it has data (here it is type of flower).</p>\\n<h2>Types</h2>\\n<ol>\\n<li>Singly Linked List</li>\\n</ol>\\n<p>Singly linked lists contain nodes which have a <code>data</code> field as well as a <code>next</code> field, which points to the next node in the sequence. Operations that can be performed on singly linked lists are insertion, deletion and traversal.</p>\\n<p>`</p>\\n<pre><code>Singly Link List\\n</code></pre>\\n<hr>\\n<pre><code>   head\\n    |\\n    |\\n  +-----+--+      +-----+--+      +-----+------+\\n  |  1  |o----->  |  2  |o----->  |  3  | NULL |\\n  +-----+--+      +-----+--+      +-----+------+\\n</code></pre>\\n<p>`</p>\\n<p>Application</p>\\n<p>Internal implementation of CPython, the frames and evaluated variables are kept on a stack.</p>\\n<p>For this we need to iterate only forward aur get the head, therefore singly linked-list is used.</p>\\n<ol>\\n<li>Doubly Linked List</li>\\n</ol>\\n<p>Doubly linked lists contain node which have <code>data</code> field, <code>next</code> field and another link field <code>prev</code> pointing to the previous node in the sequence.</p>\\n<p>`</p>\\n<p>Doubly Linked List</p>\\n<hr>\\n<pre><code>          head\\n           |\\n           |\\n  +------+-----+--+    +--+-----+--+       +-----+------+\\n  |      |     |o------>  |     |o------>  |     |      |\\n  | NULL |  1  |          |  2  |          |  3  | NULL |\\n  |      |     |  &#x3C;------o|     |  &#x3C;------o|     |      |\\n  +------+-----+--+    +--+-----+--+       +-----+------+\\n</code></pre>\\n<p>`</p>\\n<p>Application</p>\\n<p>The browser cache which allows you to hit the BACK and FORWARD button. Here we need to maintain a doubly linked list, with <code>URLs</code> as data field, to allow access in both direction. To go to previous URL we will use <code>prev</code> field and to go to next page we will use <code>next</code> field.</p>\\n<ol>\\n<li>Circular Linked List</li>\\n</ol>\\n<p>Circular linked lists is a singly linked list in which last node, <code>next</code> field points to first node in the sequence.</p>\\n<p>`</p>\\n<p>Circular Linked List</p>\\n<hr>\\n<pre><code>     head\\n      |\\n      |\\n    +-----+--+      +-----+--+      +-----+--+\\n</code></pre>\\n<p>--> | 1 |o-----> | 2 |o-----> | 3 |o----<br>\\n| +-----+--+ +-----+--+ +-----+--+ |<br>\\n| |</p>\\n<hr>\\n<p>`</p>\\n<p><strong>Application</strong></p>\\n<p>Timesharing problem solved by the operating system.</p>\\n<p>In a timesharing environment, the operating system must maintain a list of present users and must alternately allow each user to use a small portion of CPU time, one user at a time. The operating system will pick a user, let him/her use a small amount of CPU time and then move on to the next user.</p>\\n<p>For this application, there should be no NULL pointers unless there is absolutely no one requesting CPU time, i.e list is empty.</p>\\n<h2>Basic Operations</h2>\\n<ol>\\n<li>Insertion</li>\\n</ol>\\n<p>To add a new element to the list.</p>\\n<p>`</p>\\n<p>Insertion at the beginning</p>\\n<hr>\\n<ul>\\n<li>Create a new node with given data.</li>\\n<li>Point new node's <code>next</code> to old <code>head</code>.</li>\\n<li>Point <code>head</code> to this new node.</li>\\n</ul>\\n<p>Insertion in the middle/end</p>\\n<hr>\\n<p>Insertion after node X.</p>\\n<ul>\\n<li>Create a new node with given data.</li>\\n<li>Point new node's <code>next</code> to old X's <code>next</code>.</li>\\n<li>Point X's <code>next</code> to this new node.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(1)</strong></p>\\n<ol>\\n<li>Deletion</li>\\n</ol>\\n<p>To delete existing element from the list.</p>\\n<p>`</p>\\n<p>Deletion at the beginning</p>\\n<hr>\\n<ul>\\n<li>Get the node pointed by <code>head</code> as Temp.</li>\\n<li>Point <code>head</code> to Temp's <code>next</code>.</li>\\n<li>Free memory used by Temp node.</li>\\n</ul>\\n<p>Deletion in the middle/end</p>\\n<hr>\\n<p>Deletion after node X.</p>\\n<ul>\\n<li>Get the node pointed by <code>X</code> as Temp.</li>\\n<li>Point X's <code>next</code> to Temp's <code>next</code>.</li>\\n<li>Free memory used by Temp node.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(1)</strong></p>\\n<ol>\\n<li>Traversing</li>\\n</ol>\\n<p>To travel across the list.</p>\\n<p>`</p>\\n<p>Traversal</p>\\n<hr>\\n<ul>\\n<li>Get the node pointed by <code>head</code> as Current.</li>\\n<li>Check if Current is not null and display it.</li>\\n<li>Point Current to Current's <code>next</code> and move to above step.<br>\\n`</li>\\n</ul>\\n<p><strong>Time Complexity: O(n) // Here n is size of link-list</strong></p>\\n<h2>Implementation</h2>\\n<h3>C++ implementation of singly linked list</h3>\\n<pre><code>// Header files\\n#include &#x3C;iostream>\\n\\nstruct node\\n{\\n    int data;\\n    struct node *next;\\n};\\n\\n// Head pointer always points to first element of the linked list\\nstruct node *head = NULL;\\n</code></pre>\\n<h4>Printing data in each node</h4>\\n<pre><code>// Display the list\\nvoid printList()\\n{\\n    struct node *ptr = head;\\n\\n    // Start from the beginning\\nwhile(ptr != NULL)\\n{\\n    std::cout &#x3C;&#x3C; ptr->data &#x3C;&#x3C; \\\" \\\";\\n    ptr = ptr->next;\\n}\\n\\nstd::cout &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Insertion at the beginning</h4>\\n<pre><code>// Insert link at the beginning\\nvoid insertFirst(int data)\\n{\\n    // Create a new node\\n    struct node *new_node = new struct node;\\n\\n    new_node->data = data;\\n\\n// Point it to old head\\nnew_node->next = head;\\n\\n// Point head to new node\\nhead = new_node;\\n\\nstd::cout &#x3C;&#x3C; \\\"Inserted successfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Deletion at the beginning</h4>\\n<pre><code>// Delete first item\\nvoid deleteFirst()\\n{\\n    // Save reference to head\\n    struct node *temp = head;\\n\\n    // Point head to head's next\\nhead = head->next;\\n\\n// Free memory used by temp\\ntemp = NULL:\\ndelete temp;\\n\\nstd::cout &#x3C;&#x3C; \\\"Deleted successfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Size</h4>\\n<pre><code>// Find no. of nodes in link list\\nvoid size()\\n{\\n    int length = 0;\\n    struct node *current;\\n\\n    for(current = head; current != NULL; current = current->next)\\n{\\n    length++;\\n}\\n\\nstd::cout &#x3C;&#x3C; \\\"Size of Linked List is \\\" &#x3C;&#x3C; length &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Searching</h4>\\n<pre><code>// Find node with given data\\nvoid find(int data){\\n\\n    // Start from the head\\nstruct node* current = head;\\n\\n// If list is empty\\nif(head == NULL)\\n{\\n    std::cout &#x3C;&#x3C; \\\"List is empty\\\" &#x3C;&#x3C; std::endl;\\n    return;\\n}\\n\\n// Traverse through list\\nwhile(current->data != data){\\n\\n    // If it is last node\\n    if(current->next == NULL){\\n        std::cout &#x3C;&#x3C; \\\"Not Found\\\" &#x3C;&#x3C; std::endl;\\n        return;\\n    }\\n    else{\\n        // Go to next node\\n        current = current->next;\\n    }\\n}\\n\\n// If data found\\nstd::cout &#x3C;&#x3C; \\\"Found\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<h4>Deletion after a node</h4>\\n<pre><code>// Delete a node with given data\\nvoid del(int data){\\n\\n    // Start from the first node\\nstruct node* current = head;\\nstruct node* previous = NULL;\\n\\n// If list is empty\\nif(head == NULL){\\n    std::cout &#x3C;&#x3C; \\\"List is empty\\\" &#x3C;&#x3C; std::endl;\\n    return ;\\n}\\n\\n// Navigate through list\\nwhile(current->data != data){\\n\\n    // If it is last node\\n    if(current->next == NULL){\\n        std::cout &#x3C;&#x3C; \\\"Element not found\\\" &#x3C;&#x3C; std::endl;\\n        return ;\\n    }\\n    else {\\n        // Store reference to current node\\n        previous = current;\\n        // Move to next node\\n        current = current->next;\\n    }\\n\\n}\\n\\n// Found a match, update the node\\nif(current == head) {\\n    // Change head to point to next node\\n    head = head->next;\\n}\\nelse {\\n    // Skip the current node\\n    previous->next = current->next;\\n}\\n\\n// Free space used by deleted node\\ncurrent = NULL;\\ndelete current;\\nstd::cout &#x3C;&#x3C; \\\"Deleted succesfully\\\" &#x3C;&#x3C; std::endl;\\n}\\n</code></pre>\\n<p>:rocket: <a href=\\\"https://repl.it/CXVt/1\\\">Run Code</a> ### Python Implementation of Singly Linked List  </p>\\n<pre><code>class Node(object):\\n    # Constructor\\n    def __init__(self, data=None, next=None):\\n        self.data = data\\n        self.next = next\\n\\n    # Function to get data\\ndef get_data(self):\\n    return self.data\\n\\n# Function to get next node\\ndef get_next(self):\\n    return self.next\\n\\n# Function to set next field\\ndef set_next(self, new_next):\\n    self.next = new_next\\nclass LinkedList(object):\\n    def __init__(self, head=None):\\n        self.head = head\\n</code></pre>\\n<h4>Insertion</h4>\\n<pre><code>    # Function to insert data\\ndef insert(self, data):\\n    # new_node is a object of class Node\\n    new_node = Node(data)\\n    new_node.set_next(self.head)\\n    self.head = new_node\\n    print(\\\"Node with data \\\" + str(data) + \\\" is created succesfully\\\")\\n</code></pre>\\n<h4>Size</h4>\\n<pre><code>    # Function to get size\\ndef size(self):\\n    current = self.head\\n    count = 0\\n    while current:\\n        count += 1\\n        current = current.get_next()\\n    print(\\\"Size of link list is \\\" + str(count))\\n</code></pre>\\n<h4>Searching</h4>\\n<pre><code>    # Function to search a data\\ndef search(self, data):\\n    current = self.head\\n    found = False\\n    while current and found is False:\\n        if current.get_data() == data:\\n            found = True\\n        else:\\n            current = current.get_next()\\n    if current is None:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is not present\\\")\\n    else:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is found\\\")\\n</code></pre>\\n<h4>Deletion after a node</h4>\\n<pre><code>    # Function to delete a node with data\\ndef delete(self, data):\\n    current = self.head\\n    previous = None\\n    found = False\\n    while current and found is False:\\n        if current.get_data() == data:\\n            found = True\\n        else:\\n            previous = current\\n            current = current.get_next()\\n    if current is None:\\n        print(\\\"Node with data \\\" + str(data) + \\\" is not in list\\\")\\n    elif previous is None:\\n        self.head = current.get_next()\\n        print(\\\"Node with data \\\" + str(data) + \\\" is deleted successfully\\\")\\n    else:\\n        previous.set_next(current.get_next())\\n        print(\\\"Node with data \\\" + str(data) + \\\" is deleted successfully\\\")\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CVq3/2\\\">Run Code</a></p>\\n<p><strong>Advantages</strong></p>\\n<ol>\\n<li>Linked lists are a dynamic data structure, which can grow and shrink, allocating and deallocating memory while the program is running.</li>\\n<li>Insertion and deletion of node are easily implemented in a linked list at any position.</li>\\n</ol>\\n<p><strong>Disadvantages</strong></p>\\n<ol>\\n<li>They use more memory than arrays because of the memory used by their pointers (<code>next</code> and <code>prev</code>).</li>\\n<li>Random access is not possible in linked list. We have to access nodes sequentially.</li>\\n<li>It's more complex than array. If a language supports array bound check automatically, Arrays would serve you better.</li>\\n</ol>\\n<h4>Note</h4>\\n<p>We have to use free() in C and delete in C++ to free the space used by deleted node, whereas, in Python and Java free space is collected automatically by garbage collector.</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Data Structure Linked List\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/data-structure-linked-list/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/miscellaneous/data-structure-linked-list/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-miscellaneous-data-structure-linked-list.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-linked-list.json\n// module chunks = 410"],"sourceRoot":""}