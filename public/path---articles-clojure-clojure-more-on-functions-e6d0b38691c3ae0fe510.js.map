{"version":3,"sources":["webpack:///path---articles-clojure-clojure-more-on-functions-e6d0b38691c3ae0fe510.js","webpack:///./.cache/json/articles-clojure-clojure-more-on-functions.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-more-on-functions.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,oGACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,+pIACAC,aACAC,MAAA,4BACAC,OAAA,uGAIAC,aACAC,KAAA","file":"path---articles-clojure-clojure-more-on-functions-e6d0b38691c3ae0fe510.js","sourcesContent":["webpackJsonp([1800],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-more-on-functions.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>Functions! They're pretty important. It's very difficult to do anything without a function. They're integral to any language, but especially Clojure, since it's a functional programming language that rejects object-oriented design. Let's learn some more about them!</p>\\n<h2>Arity</h2>\\n<p><strong>Arity</strong> refers to the number of arguments that your function expects.</p>\\n<pre><code>;; add expects 2 arguments. Its arity is 2.\\n(defn add [x y] (+ x y))\\n(add 2 2)\\n; => 4\\n\\n;; + itself is a function, and it can have any number of arguments.\\n(+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16) ;; and so on...\\n; => 136\\n</code></pre>\\n<p>Clojure has some special syntax that allows you to let your function do different stuff depending on the number of arguments it receives. This is called variable arity.</p>\\n<pre><code>(defn foo\\n  ([]                               ; if this function gets no arguments...\\n    (println \\\"Lisa needs braces!\\\")) ; do this.\\n  ([arg1]                           ; if this function gets 1 argument...\\n    (println \\\"Dental plan!\\\")))      ; do this instead!\\n(foo)\\n; => Lisa needs braces!\\n;    nil\\n(foo \\\"this is a placeholder argument.\\\")\\n; => Dental plan!\\n;    nil\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/sXGplb\\\">IDEOne it!</a></p>\\n<h2>Anonymous functions</h2>\\n<p>Let's look at a really simple function: a function that adds 1 to a number.</p>\\n<pre><code>;; I've called this function \\\"my-inc\\\" so you don't confuse it with inc.\\n;; inc is a built-in function that already does this for us.\\n(defn my-inc [n] (+ 1 n))\\n(inc' 5)\\n; => 6\\n</code></pre>\\n<p>This looks pretty simple. It takes a single parameter - <code>n</code> - and returns <code>n + 1</code>. Let's pick it apart.</p>\\n<pre><code>(def my-inc-2 (fn [n] (+ 1 n)))\\n(inc' 5)\\n; => 6\\n</code></pre>\\n<p>You can see from this that using <code>defn</code> is just shorthand for using <code>(def ... (fn ...))</code>. But this reveals something interesting. What we're actually doing isn't 'defining a function', it's just binding an anonymous function to a special name - <code>inc'</code>. What if we don't give it a name?</p>\\n<pre><code>((fn [n] (+ 1 n)) 5)\\n; => 6\\n</code></pre>\\n<p>Bam! Boom! Kapow! Anonymous functions. This might seem useless now, but it comes in pretty handy later on for applying functions to lists using <code>map</code>, <code>reduce</code> and <code>filter</code>. Giving every function you write a name gets boring and cumbersome, fast.</p>\\n<p>There's a shorter way to write anonymous functions, intended for very short, simple functions. It does not allow for destructuring or variable arity. However, it is quite concise.</p>\\n<pre><code>(#(+ 1 %) 5)\\n; => 6\\n</code></pre>\\n<p><code>#(...)</code> is a shorthand way to define an anonymous function. <code>%</code> refers to the first argument to the function. If your function expects several arguments, you can use <code>%1, %2, ... %n</code>.</p>\\n<pre><code>(#(str %1 %2 %3) \\\"foo\\\" \\\"bar\\\" \\\"baz\\\")\\n; => \\\"foobarbaz\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/roYRgS\\\">IDEOne it!</a></p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-loop-recur/18418\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-collections/18411\\\">Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\"></a>|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-loop-recur/18418\\\">Loop and Recur</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | <a href=\\\"/http://forum.freecodecamp.com/t/clojure-collections/18411\\\">Collections</a>|</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Clojure More On Functions\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure-more-on-functions/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/clojure/clojure-more-on-functions/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-clojure-clojure-more-on-functions-e6d0b38691c3ae0fe510.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>Functions! They're pretty important. It's very difficult to do anything without a function. They're integral to any language, but especially Clojure, since it's a functional programming language that rejects object-oriented design. Let's learn some more about them!</p>\\n<h2>Arity</h2>\\n<p><strong>Arity</strong> refers to the number of arguments that your function expects.</p>\\n<pre><code>;; add expects 2 arguments. Its arity is 2.\\n(defn add [x y] (+ x y))\\n(add 2 2)\\n; => 4\\n\\n;; + itself is a function, and it can have any number of arguments.\\n(+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16) ;; and so on...\\n; => 136\\n</code></pre>\\n<p>Clojure has some special syntax that allows you to let your function do different stuff depending on the number of arguments it receives. This is called variable arity.</p>\\n<pre><code>(defn foo\\n  ([]                               ; if this function gets no arguments...\\n    (println \\\"Lisa needs braces!\\\")) ; do this.\\n  ([arg1]                           ; if this function gets 1 argument...\\n    (println \\\"Dental plan!\\\")))      ; do this instead!\\n(foo)\\n; => Lisa needs braces!\\n;    nil\\n(foo \\\"this is a placeholder argument.\\\")\\n; => Dental plan!\\n;    nil\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/sXGplb\\\">IDEOne it!</a></p>\\n<h2>Anonymous functions</h2>\\n<p>Let's look at a really simple function: a function that adds 1 to a number.</p>\\n<pre><code>;; I've called this function \\\"my-inc\\\" so you don't confuse it with inc.\\n;; inc is a built-in function that already does this for us.\\n(defn my-inc [n] (+ 1 n))\\n(inc' 5)\\n; => 6\\n</code></pre>\\n<p>This looks pretty simple. It takes a single parameter - <code>n</code> - and returns <code>n + 1</code>. Let's pick it apart.</p>\\n<pre><code>(def my-inc-2 (fn [n] (+ 1 n)))\\n(inc' 5)\\n; => 6\\n</code></pre>\\n<p>You can see from this that using <code>defn</code> is just shorthand for using <code>(def ... (fn ...))</code>. But this reveals something interesting. What we're actually doing isn't 'defining a function', it's just binding an anonymous function to a special name - <code>inc'</code>. What if we don't give it a name?</p>\\n<pre><code>((fn [n] (+ 1 n)) 5)\\n; => 6\\n</code></pre>\\n<p>Bam! Boom! Kapow! Anonymous functions. This might seem useless now, but it comes in pretty handy later on for applying functions to lists using <code>map</code>, <code>reduce</code> and <code>filter</code>. Giving every function you write a name gets boring and cumbersome, fast.</p>\\n<p>There's a shorter way to write anonymous functions, intended for very short, simple functions. It does not allow for destructuring or variable arity. However, it is quite concise.</p>\\n<pre><code>(#(+ 1 %) 5)\\n; => 6\\n</code></pre>\\n<p><code>#(...)</code> is a shorthand way to define an anonymous function. <code>%</code> refers to the first argument to the function. If your function expects several arguments, you can use <code>%1, %2, ... %n</code>.</p>\\n<pre><code>(#(str %1 %2 %3) \\\"foo\\\" \\\"bar\\\" \\\"baz\\\")\\n; => \\\"foobarbaz\\\"\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/roYRgS\\\">IDEOne it!</a></p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-loop-recur/18418\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-collections/18411\\\">Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\"></a>|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-loop-recur/18418\\\">Loop and Recur</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | <a href=\\\"/http://forum.freecodecamp.com/t/clojure-collections/18411\\\">Collections</a>|</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Clojure More On Functions\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure-more-on-functions/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/clojure/clojure-more-on-functions/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-clojure-clojure-more-on-functions.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-more-on-functions.json\n// module chunks = 1800"],"sourceRoot":""}