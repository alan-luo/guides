{"version":3,"sources":["webpack:///path---articles-miscellaneous-bitwise-operators-24f00f412cd056febb73.js","webpack:///./.cache/json/articles-miscellaneous-bitwise-operators.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-bitwise-operators.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,MAERC,kGACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,slFACAC,aACAC,MAAA,oBACAC,OAAA,qGAIAC,aACAC,KAAA","file":"path---articles-miscellaneous-bitwise-operators-24f00f412cd056febb73.js","sourcesContent":["webpackJsonp([439],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-bitwise-operators.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p><code>&#x3C;&#x3C;</code> , <code>>></code> , <code>&#x26;</code>, <code>|</code> , <code>~</code>, and <code>^</code> are the bitwise operators which operate on one or more bit patterns or binary numerals at the level of their individual bits.</p>\\n<h2>AND operator</h2>\\n<p><code>x &#x26; y</code></p>\\n<p>Does a \\\"bitwise and\\\". Each bit of the output is 1 if the corresponding bit of x AND of y is 1, otherwise it's 0.</p>\\n<h2>OR operator</h2>\\n<p><code>x | y</code></p>\\n<p>Does a \\\"bitwise or\\\". Each bit of the output is 0 if the corresponding bit of x AND of y is 0, otherwise it's 1.</p>\\n<h2>Complement operator</h2>\\n<p><code>~ x</code></p>\\n<p>Returns the complement of x - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1.</p>\\n<h2>XOR operator</h2>\\n<p><code>x ^ y</code></p>\\n<p>Does a \\\"bitwise exclusive or\\\". Each bit of the output is the same as the corresponding bit in x if that bit in y is 0, and it's the complement of the bit in x if that bit in y is 1.</p>\\n<h2>Arithmetic shift left operator</h2>\\n<p><code>x &#x3C;&#x3C; y</code></p>\\n<p>Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is same as multiplying x by 2**y, preserving the sign of the number. Most of the compilers throw a warning when you shift with a count >= sizeof(type). You generally end up with a 0 when you do that.</p>\\n<h2>Arithmetic shift right operator</h2>\\n<p><code>x >> y</code></p>\\n<p>Returns x with the bits shifted to the right by y places. This is same as dividing x by 2**y for an unsigned integer. Right shift of a negative signed number has implementation-defined behaviour. Most of the compilers throw a warning when you shift with a count >= sizeof(type). Shifting it right may fill \\\"empty\\\" bits with the original Most Significant Bit (i.e. perform sign extension) or it may shift in zeroes, depending on platform and/or compiler.</p>\\n<h2>Logical shift right operator</h2>\\n<p><code>x >>> y</code></p>\\n<p>Returns x with the bits shifted to the right by y places. Unlike arithmetic shift, logical shifts do not preseve sign. For example: -2 represented in 8 bits would be 11111110 (because the most significant bit has negative weight). Shifting it right one bit using arithmetic shift would give you 11111111, or -1. Logical right shift, however, does not care that the value could possibly represent a number; it simply moves everything to the right and fills in from the left with 0s. Shifting our -2 right one bit using logical shift would give 01111111. This operator is not necessirly present in all languages.</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Bitwise Operators\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/bitwise-operators/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/miscellaneous/bitwise-operators/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-miscellaneous-bitwise-operators-24f00f412cd056febb73.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p><code>&#x3C;&#x3C;</code> , <code>>></code> , <code>&#x26;</code>, <code>|</code> , <code>~</code>, and <code>^</code> are the bitwise operators which operate on one or more bit patterns or binary numerals at the level of their individual bits.</p>\\n<h2>AND operator</h2>\\n<p><code>x &#x26; y</code></p>\\n<p>Does a \\\"bitwise and\\\". Each bit of the output is 1 if the corresponding bit of x AND of y is 1, otherwise it's 0.</p>\\n<h2>OR operator</h2>\\n<p><code>x | y</code></p>\\n<p>Does a \\\"bitwise or\\\". Each bit of the output is 0 if the corresponding bit of x AND of y is 0, otherwise it's 1.</p>\\n<h2>Complement operator</h2>\\n<p><code>~ x</code></p>\\n<p>Returns the complement of x - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1.</p>\\n<h2>XOR operator</h2>\\n<p><code>x ^ y</code></p>\\n<p>Does a \\\"bitwise exclusive or\\\". Each bit of the output is the same as the corresponding bit in x if that bit in y is 0, and it's the complement of the bit in x if that bit in y is 1.</p>\\n<h2>Arithmetic shift left operator</h2>\\n<p><code>x &#x3C;&#x3C; y</code></p>\\n<p>Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is same as multiplying x by 2**y, preserving the sign of the number. Most of the compilers throw a warning when you shift with a count >= sizeof(type). You generally end up with a 0 when you do that.</p>\\n<h2>Arithmetic shift right operator</h2>\\n<p><code>x >> y</code></p>\\n<p>Returns x with the bits shifted to the right by y places. This is same as dividing x by 2**y for an unsigned integer. Right shift of a negative signed number has implementation-defined behaviour. Most of the compilers throw a warning when you shift with a count >= sizeof(type). Shifting it right may fill \\\"empty\\\" bits with the original Most Significant Bit (i.e. perform sign extension) or it may shift in zeroes, depending on platform and/or compiler.</p>\\n<h2>Logical shift right operator</h2>\\n<p><code>x >>> y</code></p>\\n<p>Returns x with the bits shifted to the right by y places. Unlike arithmetic shift, logical shifts do not preseve sign. For example: -2 represented in 8 bits would be 11111110 (because the most significant bit has negative weight). Shifting it right one bit using arithmetic shift would give you 11111111, or -1. Logical right shift, however, does not care that the value could possibly represent a number; it simply moves everything to the right and fills in from the left with 0s. Shifting our -2 right one bit using logical shift would give 01111111. This operator is not necessirly present in all languages.</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Bitwise Operators\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/bitwise-operators/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/miscellaneous/bitwise-operators/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-miscellaneous-bitwise-operators.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-bitwise-operators.json\n// module chunks = 439"],"sourceRoot":""}