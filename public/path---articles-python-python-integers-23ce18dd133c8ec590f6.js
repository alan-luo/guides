webpackJsonp([179],{"./node_modules/json-loader/index.js!./.cache/json/articles-python-python-integers.json":function(e,n){e.exports={data:{markdownRemark:{html:"<p>The theoretical domain for integers in python is negative infinity to infinity. In practice, integer values are limited by the amount of available memory.</p>\n<p>In Python 2, there was a distinction between <strong><code>int</code></strong>, numbers that fit in a 32 or 64 bit <em>C long</em>, and <strong><code>long</code></strong>, numbers limited by available memory. Python 3 unified the two types into just <strong><code>int</code></strong>, more info in <a href=\"https://www.python.org/dev/peps/pep-0237/\">PEP 237</a>.</p>\n<p><strong><code>int</code> creation using integer literals</strong></p>\n<p><a href=\"https://docs.python.org/3/reference/lexical_analysis.html#integer-literals\">Integer Literals</a></p>\n<p><em>Integer objects</em> can be created using using integer literals. Unadorned numbers without decimals are integer literals:</p>\n<pre><code>>>> 1234567890           # Unadorned numbers are integer literals\n1234567890\n>>> type(1234567890)\n&#x3C;class 'int'>\n</code></pre>\n<p>Numeric literals do not contain a sign, however creating negative <em>integer objects</em> is possible by prefixing with a unary <code>-</code> (minus) operator with no space before the literal:</p>\n<pre><code>>>> -1234567890\n-1234567890\n>>> type(-1234567890)\n&#x3C;class 'int'>\n</code></pre>\n<p>Likewise, positive integer objects can be created by prefixing a unary <code>+</code> (plus) operator with no space before the digits. Usually <code>+</code> is ommited:</p>\n<pre><code>>>> +1234\n1234\n</code></pre>\n<p>Binary (base 2, prefix: <code>0b</code> or <code>0B</code>), octal (base 8, prefix: <code>0o</code> or <code>0O</code>), and hexadecimal (base 16, prefix: <code>0x</code> or <code>0X</code>) integers can also be created using integer literals:</p>\n<pre><code>>>> 0b1, 0b10, 0b11\n(1, 2, 3)\n>>> 0o1, 0o10, 0o11\n(1, 8, 9)\n>>> 0x1, 0x10, 0x11\n(1, 16, 17)\n</code></pre>\n<p>Note that leading 0's for non-zero integer literals are <strong>not allowed</strong>:</p>\n<pre><code>>>> 0     # Zero by itself is okay.\n0\n>>> 01    # Leading zero(s) cause SyntaxError.\n  File \"&#x3C;stdin>\", line 1\n    01\n     ^\nSyntaxError: invalid token\n</code></pre>\n<p>The <code>int</code> <a href=\"https://docs.python.org/3/library/functions.html#int\">constructor</a> is another way to create <em>integer objects</em>.</p>\n<pre><code>class int(x=0)\nclass int(x, base=10)\n</code></pre>\n<p>Creating <em>integer objects</em> with integer literals is preferred when possible:</p>\n<pre><code>>>> a = 1         # Prefer integer literal when possible.\n>>> type(a)\n&#x3C;class 'int'>\n>>> b = int(1)    # Works but unnecessary.\n>>> type(b)\n&#x3C;class 'int'>\n</code></pre>\n<p>However, the constructor allows for creating <em>integer objects</em> from other number types:</p>\n<pre><code>>>> a = 1.123\n>>> type(a)\n&#x3C;class 'float'>\n>>> print(a)\n1.123\n>>> b = int(1.123)\n>>> type(b)\n&#x3C;class 'int'>\n>>> print(b)\n1\n</code></pre>\n<p>Using the <code>int</code> constructor for floating point numbers will truncate the number towards zero:</p>\n<pre><code>>>> int(-1.23)\n-1\n>>> int(1.23)\n1\n</code></pre>\n<p>The built-in <code>boolean</code> constants are instances of the <code>bool</code> class, and are subclasses of the <code>int</code> class, making them a kind of numeric type:</p>\n<pre><code>>>> type(True)\n&#x3C;class 'bool'>\n>>> issubclass(bool, int)\nTrue\n</code></pre>\n<p>If that doesn't make sense to you, don't worry. For now just remember that calling the int constructor with <code>boolean</code> objects will return <em>integer objects</em>:</p>\n<pre><code>>>> int(True)\n1\n>>> int(False)\n0\n</code></pre>\n<p>The <code>int</code> constructor will also make <em>integer objects</em> from strings:</p>\n<pre><code>>>> a = \"10\"\n>>> type(a)\n&#x3C;class 'str'>\n>>> b = int(\"10\")\n>>> type(b)\n&#x3C;class 'int'>\n</code></pre>\n<p><em>Strings</em> for the <code>int</code> constructor must represent an integer literal:</p>\n<p>The second parameter of the <code>int</code> constructor is to specify a base (default: 10). Valid bases are 0 and 2-36.</p>\n<p>If an explicit base is provided the first argument must be a string.</p>\n<pre><code>>>> int(\"111\", 2)\n7\n>>> int(111, 2)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nTypeError: int() can't convert non-string with explicit base\n</code></pre>\n<p>The string used for the <code>int</code> constructor with an explicit base must be a valid integer literal for that base:</p>\n<pre><code>>>> int('11', 2)\n3\n>>> int('12', 2)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nValueError: invalid literal for int() with base 2: '12'\n</code></pre>\n<p>Both prefixed and non-prefixed strings of integer literals can be used, however, if used, the prefix must match the provided base.</p>\n<pre><code>>>> int('1101', 2)\n13\n>>> int('0b1101', 2)\n13\n>>> int('0x1101', 2)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nValueError: invalid literal for int() with base 2: '0x1101'\n</code></pre>\n<p>If a prefixed string and base 0 is used, the created integer object will use the base specified by the prefix. If no prefix is used, then the base is assumed 10</p>\n<pre><code>>>> int('100', 0)\n100\n>>> int('0b100', 0)\n4\n>>> int('0o100', 0)\n64\n</code></pre>",frontmatter:{title:"Python Integers",parent:"/home/stuart/guides/src/pages/articles/python/python-integers/index.md absPath of file"}}},pathContext:{slug:"/articles/python/python-integers/"}}}});
//# sourceMappingURL=path---articles-python-python-integers-23ce18dd133c8ec590f6.js.map