{"version":3,"sources":["webpack:///path---articles-javascript-javascript-isloggedinasync-868a17b5c021fe4ba8cb.js","webpack:///./.cache/json/articles-javascript-javascript-isloggedinasync.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-javascript-javascript-isloggedinasync.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,wGACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,87BACAC,aACAC,MAAA,6BACAC,OAAA,2GAIAC,aACAC,KAAA","file":"path---articles-javascript-javascript-isloggedinasync-868a17b5c021fe4ba8cb.js","sourcesContent":["webpackJsonp([1196],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-javascript-javascript-isloggedinasync.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>Let's say you have a public page, but if the user is logged in you want to show special information to them. You'll need to detect if a user is logged in before you make an <em>$http</em> call, right? It's not guaranteed that this will work, because <em>isLoggedIn()</em> is actually an async call. If you want to force something to wait until after <em>isLoggedIn()</em> is successful before it gets called, you should include <em>Auth.isLoggedInAsync</em>:</p>\\n<pre><code>$scope.isLoggedInAsync = Auth.isLoggedInAsync;\\n</code></pre>\\n<p><em>isLoggedInAsync</em> takes a callback function as an input, and passes the callback function a <em>true</em> boolean if the user is logged in, and a <em>false</em> if the user is not. You can call it like so:</p>\\n<pre><code>$scope.isLoggedInAsync(callback(bool) {\\n    if (bool) { /** do thing if they’re logged in **/ }\\n    else { /** do different thing if they’re not logged in **/ }\\n});\\n</code></pre>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"javaScript Isloggedinasync\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/javascript/javascript-isloggedinasync/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/javascript/javascript-isloggedinasync/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-javascript-javascript-isloggedinasync-868a17b5c021fe4ba8cb.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>Let's say you have a public page, but if the user is logged in you want to show special information to them. You'll need to detect if a user is logged in before you make an <em>$http</em> call, right? It's not guaranteed that this will work, because <em>isLoggedIn()</em> is actually an async call. If you want to force something to wait until after <em>isLoggedIn()</em> is successful before it gets called, you should include <em>Auth.isLoggedInAsync</em>:</p>\\n<pre><code>$scope.isLoggedInAsync = Auth.isLoggedInAsync;\\n</code></pre>\\n<p><em>isLoggedInAsync</em> takes a callback function as an input, and passes the callback function a <em>true</em> boolean if the user is logged in, and a <em>false</em> if the user is not. You can call it like so:</p>\\n<pre><code>$scope.isLoggedInAsync(callback(bool) {\\n    if (bool) { /** do thing if they’re logged in **/ }\\n    else { /** do different thing if they’re not logged in **/ }\\n});\\n</code></pre>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"javaScript Isloggedinasync\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/javascript/javascript-isloggedinasync/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/javascript/javascript-isloggedinasync/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-javascript-javascript-isloggedinasync.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-javascript-javascript-isloggedinasync.json\n// module chunks = 1196"],"sourceRoot":""}