{"version":3,"sources":["webpack:///path---articles-java-java-docs-strings-7165c4a14597c5a6f416.js","webpack:///./.cache/json/articles-java-java-docs-strings.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-strings.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,yFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,8iFACAC,aACAC,MAAA,oBACAC,OAAA,4FAIAC,aACAC,KAAA","file":"path---articles-java-java-docs-strings-7165c4a14597c5a6f416.js","sourcesContent":["webpackJsonp([1552],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-strings.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<h1>Java Strings</h1>\\n<p>Strings, as you might be already aware, are a sequence of characters. In Java, a <code>String</code> is an <code>Object</code>.</p>\\n<pre><code>String course = \\\"FCC\\\";\\nSystem.out.println( course instanceof Object); //&#x3C;- This prints 'true'\\n</code></pre>\\n<p>You can create a String in the following ways:</p>\\n<ol>\\n<li><code>String str = \\\"I am a String\\\";</code> //This is a String literal</li>\\n<li><code>String str = new String(\\\"I am a String\\\")</code>; //This is a String Object</li>\\n</ol>\\n<p>You might be thinking: What's the difference between the two?</p>\\n<p>Well, using the <code>new</code> keyword gurantees that a new <code>String</code> object will be created and a new memory location will be allocated in the <code>Heap</code> memory (Click here to learn more)[<a href=\\\"https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html\\\">https://docs.oracle.com/cd/E13150<em>01/jrockit</em>jvm/jrockit/geninfo/diagnos/garbage_collect.html</a>]. You see, Java takes care of memory allocation and collecting unused memory in the background - among other things. However, in this case, it's good to be aware about the difference so that you can write code that can help the JVM make appropriate optimizations.</p>\\n<p>The following snippet will make things more clearer. The objective is to understand: How many String objects are created?</p>\\n<pre><code> String str = \\\"This is a string\\\";\\n String str2 = \\\"This is a string\\\";\\n String str3 = new String(\\\"This is a string\\\");\\n\\n System.out.println( str == str2 ); //This prints true\\n System.out.println( str == str3 ); //This prints false\\n</code></pre>\\n<p>The answer is: 2 String objects are created.</p>\\n<p>You see, the creators of the JVM are pretty smart. They figured that Strings differ mostly in terms of its <code>content</code>. When you create a String literal, the JVM internally checks, what is known as <code>the String pool</code>, to see if it can find a similar (content wise) String object. If it finds it, it returns the same reference. Otherwise, it just goes ahead and creates a new String object in the pool so that the same check can be performed in the future.</p>\\n<p>However, whenever you use the <code>new</code> keyword, it no longer performs this check. So, there could be a 1000s of String objects with the same content and yet, it'll go ahead and create a new String - using up additional memory. This is precisely why it's a good practice to use <code>String literals</code> instead of using the <code>new</code> keyword as much as possible.</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Java Docs Strings\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/java/java-docs-strings/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/java/java-docs-strings/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-java-java-docs-strings-7165c4a14597c5a6f416.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<h1>Java Strings</h1>\\n<p>Strings, as you might be already aware, are a sequence of characters. In Java, a <code>String</code> is an <code>Object</code>.</p>\\n<pre><code>String course = \\\"FCC\\\";\\nSystem.out.println( course instanceof Object); //&#x3C;- This prints 'true'\\n</code></pre>\\n<p>You can create a String in the following ways:</p>\\n<ol>\\n<li><code>String str = \\\"I am a String\\\";</code> //This is a String literal</li>\\n<li><code>String str = new String(\\\"I am a String\\\")</code>; //This is a String Object</li>\\n</ol>\\n<p>You might be thinking: What's the difference between the two?</p>\\n<p>Well, using the <code>new</code> keyword gurantees that a new <code>String</code> object will be created and a new memory location will be allocated in the <code>Heap</code> memory (Click here to learn more)[<a href=\\\"https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html\\\">https://docs.oracle.com/cd/E13150<em>01/jrockit</em>jvm/jrockit/geninfo/diagnos/garbage_collect.html</a>]. You see, Java takes care of memory allocation and collecting unused memory in the background - among other things. However, in this case, it's good to be aware about the difference so that you can write code that can help the JVM make appropriate optimizations.</p>\\n<p>The following snippet will make things more clearer. The objective is to understand: How many String objects are created?</p>\\n<pre><code> String str = \\\"This is a string\\\";\\n String str2 = \\\"This is a string\\\";\\n String str3 = new String(\\\"This is a string\\\");\\n\\n System.out.println( str == str2 ); //This prints true\\n System.out.println( str == str3 ); //This prints false\\n</code></pre>\\n<p>The answer is: 2 String objects are created.</p>\\n<p>You see, the creators of the JVM are pretty smart. They figured that Strings differ mostly in terms of its <code>content</code>. When you create a String literal, the JVM internally checks, what is known as <code>the String pool</code>, to see if it can find a similar (content wise) String object. If it finds it, it returns the same reference. Otherwise, it just goes ahead and creates a new String object in the pool so that the same check can be performed in the future.</p>\\n<p>However, whenever you use the <code>new</code> keyword, it no longer performs this check. So, there could be a 1000s of String objects with the same content and yet, it'll go ahead and create a new String - using up additional memory. This is precisely why it's a good practice to use <code>String literals</code> instead of using the <code>new</code> keyword as much as possible.</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Java Docs Strings\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/java/java-docs-strings/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/java/java-docs-strings/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-java-java-docs-strings.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-strings.json\n// module chunks = 1552"],"sourceRoot":""}