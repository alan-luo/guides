webpackJsonp([2029],{"./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-looprecur.json":function(e,o){e.exports={data:{markdownRemark:{html:'<p>You may need to understand <a href="//forum.freecodecamp.com/t/clojure-conditionals/18412"><code>if</code></a> and <a href="//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415"><code>let</code></a> to fully grasp recursion in Clojure.</p>\n<h2><code>for</code> and <code>while</code></h2>\n<p>Clojure does not have for loops or while loops. This makes sense, if you think about it. A <code>for</code> loop changes a variable, and that\'s not allowed in Clojure.</p>\n<pre><code>for (var i = 0; i &#x3C; 10; i++) {\n  console.log(i);\n}\n</code></pre>\n<p><code>i++</code> means that we add one to the variable <code>i</code> every time the loop finishes -- a clear example of a variable being mutated.</p>\n<p><code>while</code> loops are less obviously reliant on changing variables, but they are, just as much as for loops are.</p>\n<pre><code>var i = 0;\nwhile (i &#x3C; 10) {\n  console.log(i);\n  i++;\n}\n</code></pre>\n<p><code>while</code> loops always have a condition, like <code>i &#x3C; 10</code>, and will break if that condition is no longer true. This means that they have to have some kind of side effect (like adding 1 to <code>i</code>) so that the condition will eventually be false; otherwise, the loop would last forever.</p>\n<h2>Recursion</h2>\n<p>Thankfully, Clojure does have one loops of some kind. These loops use recursion -- a function that calls itself. The simplest recursive algorithm is one to find a positive number factorial (5 factorial, for example, equals <code>5 * 4 * 3 * 2</code>).</p>\n<pre><code>(defn fact [x]\n  (loop [n x prod 1] ;; this works just like a \'let\' binding.\n    (if (= 1 n)  ;; this is the base case.\n      prod\n      (recur (dec n) (* prod n)))))\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://ideone.com/3iP3tI">IDEOne it!</a></p>\n<p>You\'ll notice that <code>(loop [n x prod 1] ...)</code> looks quite similar to a <code>let</code> binding. It actually works in just the same way -- here, we bind <code>n</code> to <code>x</code>, and <code>prod</code> to 1.</p>\n<p>Every recursive function has a "base case". This is the condition that makes the loop stop looping. In this case, our loop stops if <code>n = 1</code>, and returns <code>prod</code>. If <code>n</code> isn\'t equal to 1, then the loop recurs.</p>\n<pre><code>(recur (dec n) (* prod n))\n</code></pre>\n<p>This <code>recur</code> function restarts the loop, but with different bindings. This time, <code>n</code> isn\'t bound to <code>x</code>, but is instead bound to <code>(dec n)</code> (which means <code>decrement n</code>, or <code>n - 1</code>), and <code>prod</code> is bound to <code>(* prod n)</code>.</p>\n<p>So when we call the function, this is what happens:</p>\n<pre><code>(fact 5)\n; Loop 1: 5 != 1, so the loop recurs with 4 (5 - 1) and 5 (1 * 5).\n; Loop 2: 4 != 1, so the loop recurs with 3 (4 - 1) and 20 (5 * 4).\n; Loop 3: 3 != 1, so the loop recurs with 2 (3 - 1) and 60 (20 * 3).\n; Loop 4: 2 != 1, so the loop recurs with 1 (2 - 1) and 120 (60 * 2).\n; Loop 5: 1 == 1, so the function returns prod, which is now equal to 120.\n; => 120\n</code></pre>\n<p>The ingenious thing about recursion is that the variables themselves are never changed. The only thing that changes is what <code>n</code> and <code>prod</code> <em>refer to</em>. We never say, <code>n--</code>, or <code>n += 2</code>.</p>\n<h2>Why use loop/recur?</h2>\n<p>You might be wondering why you would use <code>loop/recur</code> rather than simply defining a function that calls itself. Our factorial function could have been written like this:</p>\n<pre><code>(defn fact-no-loop [n]\n  (if (= 1 n)\n    1\n    (* n (fact-no-loop (dec n)))))\n</code></pre>\n<p>This is more concise, and works in a similar way. Why would you <em>ever</em> use loop and recur?</p>\n<h3>Tail Call Optimisation</h3>\n<p>If you use <code>loop/recur</code>, then the compiler (the software that turns Clojure code into JVM bytecode) knows that you want to create a recursive loop. This means that it tries its hardest to optimise your code for recursion. Let\'s compare the speed of <code>fact</code> and <code>fact-no-loop</code>:</p>\n<pre><code>(time (fact 20))\n; => "Elapsed time: 0.083927 msecs"\n;    2432902008176640000\n(time (fact-no-loop 20))\n; => "Elapsed time: 0.064937 msecs"\n;    2432902008176640000\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://ideone.com/tpC0Xo">IDEOne it!</a></p>\n<p>At this scale, the difference is negligible. In fact, <code>fact-no-loop</code> is occasionally faster than <code>fact</code> due to the unpredictable nature of computer memory. However, on a larger scale, this kind of optimisation can make your code much, much quicker.</p>\n<h3>Nesting Recursion Within functions</h3>\n<p><code>fact-no-loop</code> works without <code>loop/recur</code> because the entire function is recursive. What if we wanted part of our function to use a recursive loop, and then the rest of it to do something non-recursive? We\'d have to define two entirely separate functions. Using <code>loop/recur</code> lets us use a little anonymous function instead.</p>\n<p>| <a href="//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415"><img src="//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2" alt=":point_left:" title=":point_left:"> Previous</a> | <a href="//forum.freecodecamp.com/t/clojure-resources/18422"><img src="//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2" alt=":book:" title=":book:"> Home <img src="//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2" alt=":book:" title=":book:"></a> | Next <img src="//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2" alt=":point_right:" title=":point_right:">|<br>\n| <a href="//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415">Let Bindings</a> | <a href="//forum.freecodecamp.com/t/clojure-resources/18422">Table of Contents</a> | To Be Added |</p>',frontmatter:{title:"Clojure   Looprecur",parent:"/home/stuart/guides/src/pages/articles/clojure/clojure---looprecur/index.md absPath of file"}}},pathContext:{slug:"/articles/clojure/clojure---looprecur/"}}}});
//# sourceMappingURL=path---articles-clojure-clojure-looprecur-789dd1b78e95323906cd.js.map