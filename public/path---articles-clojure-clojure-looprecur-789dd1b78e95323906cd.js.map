{"version":3,"sources":["webpack:///path---articles-clojure-clojure-looprecur-789dd1b78e95323906cd.js","webpack:///./.cache/json/articles-clojure-clojure-looprecur.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-looprecur.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,OAERC,4FACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,ogMACAC,aACAC,MAAA,sBACAC,OAAA,iGAIAC,aACAC,KAAA","file":"path---articles-clojure-clojure-looprecur-789dd1b78e95323906cd.js","sourcesContent":["webpackJsonp([2029],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-looprecur.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>You may need to understand <a href=\\\"//forum.freecodecamp.com/t/clojure-conditionals/18412\\\"><code>if</code></a> and <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><code>let</code></a> to fully grasp recursion in Clojure.</p>\\n<h2><code>for</code> and <code>while</code></h2>\\n<p>Clojure does not have for loops or while loops. This makes sense, if you think about it. A <code>for</code> loop changes a variable, and that's not allowed in Clojure.</p>\\n<pre><code>for (var i = 0; i &#x3C; 10; i++) {\\n  console.log(i);\\n}\\n</code></pre>\\n<p><code>i++</code> means that we add one to the variable <code>i</code> every time the loop finishes -- a clear example of a variable being mutated.</p>\\n<p><code>while</code> loops are less obviously reliant on changing variables, but they are, just as much as for loops are.</p>\\n<pre><code>var i = 0;\\nwhile (i &#x3C; 10) {\\n  console.log(i);\\n  i++;\\n}\\n</code></pre>\\n<p><code>while</code> loops always have a condition, like <code>i &#x3C; 10</code>, and will break if that condition is no longer true. This means that they have to have some kind of side effect (like adding 1 to <code>i</code>) so that the condition will eventually be false; otherwise, the loop would last forever.</p>\\n<h2>Recursion</h2>\\n<p>Thankfully, Clojure does have one loops of some kind. These loops use recursion -- a function that calls itself. The simplest recursive algorithm is one to find a positive number factorial (5 factorial, for example, equals <code>5 * 4 * 3 * 2</code>).</p>\\n<pre><code>(defn fact [x]\\n  (loop [n x prod 1] ;; this works just like a 'let' binding.\\n    (if (= 1 n)  ;; this is the base case.\\n      prod\\n      (recur (dec n) (* prod n)))))\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/3iP3tI\\\">IDEOne it!</a></p>\\n<p>You'll notice that <code>(loop [n x prod 1] ...)</code> looks quite similar to a <code>let</code> binding. It actually works in just the same way -- here, we bind <code>n</code> to <code>x</code>, and <code>prod</code> to 1.</p>\\n<p>Every recursive function has a \\\"base case\\\". This is the condition that makes the loop stop looping. In this case, our loop stops if <code>n = 1</code>, and returns <code>prod</code>. If <code>n</code> isn't equal to 1, then the loop recurs.</p>\\n<pre><code>(recur (dec n) (* prod n))\\n</code></pre>\\n<p>This <code>recur</code> function restarts the loop, but with different bindings. This time, <code>n</code> isn't bound to <code>x</code>, but is instead bound to <code>(dec n)</code> (which means <code>decrement n</code>, or <code>n - 1</code>), and <code>prod</code> is bound to <code>(* prod n)</code>.</p>\\n<p>So when we call the function, this is what happens:</p>\\n<pre><code>(fact 5)\\n; Loop 1: 5 != 1, so the loop recurs with 4 (5 - 1) and 5 (1 * 5).\\n; Loop 2: 4 != 1, so the loop recurs with 3 (4 - 1) and 20 (5 * 4).\\n; Loop 3: 3 != 1, so the loop recurs with 2 (3 - 1) and 60 (20 * 3).\\n; Loop 4: 2 != 1, so the loop recurs with 1 (2 - 1) and 120 (60 * 2).\\n; Loop 5: 1 == 1, so the function returns prod, which is now equal to 120.\\n; => 120\\n</code></pre>\\n<p>The ingenious thing about recursion is that the variables themselves are never changed. The only thing that changes is what <code>n</code> and <code>prod</code> <em>refer to</em>. We never say, <code>n--</code>, or <code>n += 2</code>.</p>\\n<h2>Why use loop/recur?</h2>\\n<p>You might be wondering why you would use <code>loop/recur</code> rather than simply defining a function that calls itself. Our factorial function could have been written like this:</p>\\n<pre><code>(defn fact-no-loop [n]\\n  (if (= 1 n)\\n    1\\n    (* n (fact-no-loop (dec n)))))\\n</code></pre>\\n<p>This is more concise, and works in a similar way. Why would you <em>ever</em> use loop and recur?</p>\\n<h3>Tail Call Optimisation</h3>\\n<p>If you use <code>loop/recur</code>, then the compiler (the software that turns Clojure code into JVM bytecode) knows that you want to create a recursive loop. This means that it tries its hardest to optimise your code for recursion. Let's compare the speed of <code>fact</code> and <code>fact-no-loop</code>:</p>\\n<pre><code>(time (fact 20))\\n; => \\\"Elapsed time: 0.083927 msecs\\\"\\n;    2432902008176640000\\n(time (fact-no-loop 20))\\n; => \\\"Elapsed time: 0.064937 msecs\\\"\\n;    2432902008176640000\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/tpC0Xo\\\">IDEOne it!</a></p>\\n<p>At this scale, the difference is negligible. In fact, <code>fact-no-loop</code> is occasionally faster than <code>fact</code> due to the unpredictable nature of computer memory. However, on a larger scale, this kind of optimisation can make your code much, much quicker.</p>\\n<h3>Nesting Recursion Within functions</h3>\\n<p><code>fact-no-loop</code> works without <code>loop/recur</code> because the entire function is recursive. What if we wanted part of our function to use a recursive loop, and then the rest of it to do something non-recursive? We'd have to define two entirely separate functions. Using <code>loop/recur</code> lets us use a little anonymous function instead.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\">|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\">Let Bindings</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Clojure   Looprecur\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure---looprecur/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/clojure/clojure---looprecur/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-clojure-clojure-looprecur-789dd1b78e95323906cd.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>You may need to understand <a href=\\\"//forum.freecodecamp.com/t/clojure-conditionals/18412\\\"><code>if</code></a> and <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><code>let</code></a> to fully grasp recursion in Clojure.</p>\\n<h2><code>for</code> and <code>while</code></h2>\\n<p>Clojure does not have for loops or while loops. This makes sense, if you think about it. A <code>for</code> loop changes a variable, and that's not allowed in Clojure.</p>\\n<pre><code>for (var i = 0; i &#x3C; 10; i++) {\\n  console.log(i);\\n}\\n</code></pre>\\n<p><code>i++</code> means that we add one to the variable <code>i</code> every time the loop finishes -- a clear example of a variable being mutated.</p>\\n<p><code>while</code> loops are less obviously reliant on changing variables, but they are, just as much as for loops are.</p>\\n<pre><code>var i = 0;\\nwhile (i &#x3C; 10) {\\n  console.log(i);\\n  i++;\\n}\\n</code></pre>\\n<p><code>while</code> loops always have a condition, like <code>i &#x3C; 10</code>, and will break if that condition is no longer true. This means that they have to have some kind of side effect (like adding 1 to <code>i</code>) so that the condition will eventually be false; otherwise, the loop would last forever.</p>\\n<h2>Recursion</h2>\\n<p>Thankfully, Clojure does have one loops of some kind. These loops use recursion -- a function that calls itself. The simplest recursive algorithm is one to find a positive number factorial (5 factorial, for example, equals <code>5 * 4 * 3 * 2</code>).</p>\\n<pre><code>(defn fact [x]\\n  (loop [n x prod 1] ;; this works just like a 'let' binding.\\n    (if (= 1 n)  ;; this is the base case.\\n      prod\\n      (recur (dec n) (* prod n)))))\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/3iP3tI\\\">IDEOne it!</a></p>\\n<p>You'll notice that <code>(loop [n x prod 1] ...)</code> looks quite similar to a <code>let</code> binding. It actually works in just the same way -- here, we bind <code>n</code> to <code>x</code>, and <code>prod</code> to 1.</p>\\n<p>Every recursive function has a \\\"base case\\\". This is the condition that makes the loop stop looping. In this case, our loop stops if <code>n = 1</code>, and returns <code>prod</code>. If <code>n</code> isn't equal to 1, then the loop recurs.</p>\\n<pre><code>(recur (dec n) (* prod n))\\n</code></pre>\\n<p>This <code>recur</code> function restarts the loop, but with different bindings. This time, <code>n</code> isn't bound to <code>x</code>, but is instead bound to <code>(dec n)</code> (which means <code>decrement n</code>, or <code>n - 1</code>), and <code>prod</code> is bound to <code>(* prod n)</code>.</p>\\n<p>So when we call the function, this is what happens:</p>\\n<pre><code>(fact 5)\\n; Loop 1: 5 != 1, so the loop recurs with 4 (5 - 1) and 5 (1 * 5).\\n; Loop 2: 4 != 1, so the loop recurs with 3 (4 - 1) and 20 (5 * 4).\\n; Loop 3: 3 != 1, so the loop recurs with 2 (3 - 1) and 60 (20 * 3).\\n; Loop 4: 2 != 1, so the loop recurs with 1 (2 - 1) and 120 (60 * 2).\\n; Loop 5: 1 == 1, so the function returns prod, which is now equal to 120.\\n; => 120\\n</code></pre>\\n<p>The ingenious thing about recursion is that the variables themselves are never changed. The only thing that changes is what <code>n</code> and <code>prod</code> <em>refer to</em>. We never say, <code>n--</code>, or <code>n += 2</code>.</p>\\n<h2>Why use loop/recur?</h2>\\n<p>You might be wondering why you would use <code>loop/recur</code> rather than simply defining a function that calls itself. Our factorial function could have been written like this:</p>\\n<pre><code>(defn fact-no-loop [n]\\n  (if (= 1 n)\\n    1\\n    (* n (fact-no-loop (dec n)))))\\n</code></pre>\\n<p>This is more concise, and works in a similar way. Why would you <em>ever</em> use loop and recur?</p>\\n<h3>Tail Call Optimisation</h3>\\n<p>If you use <code>loop/recur</code>, then the compiler (the software that turns Clojure code into JVM bytecode) knows that you want to create a recursive loop. This means that it tries its hardest to optimise your code for recursion. Let's compare the speed of <code>fact</code> and <code>fact-no-loop</code>:</p>\\n<pre><code>(time (fact 20))\\n; => \\\"Elapsed time: 0.083927 msecs\\\"\\n;    2432902008176640000\\n(time (fact-no-loop 20))\\n; => \\\"Elapsed time: 0.064937 msecs\\\"\\n;    2432902008176640000\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://ideone.com/tpC0Xo\\\">IDEOne it!</a></p>\\n<p>At this scale, the difference is negligible. In fact, <code>fact-no-loop</code> is occasionally faster than <code>fact</code> due to the unpredictable nature of computer memory. However, on a larger scale, this kind of optimisation can make your code much, much quicker.</p>\\n<h3>Nesting Recursion Within functions</h3>\\n<p><code>fact-no-loop</code> works without <code>loop/recur</code> because the entire function is recursive. What if we wanted part of our function to use a recursive loop, and then the rest of it to do something non-recursive? We'd have to define two entirely separate functions. Using <code>loop/recur</code> lets us use a little anonymous function instead.</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" alt=\\\":point_left:\\\" title=\\\":point_left:\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" alt=\\\":book:\\\" title=\\\":book:\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" alt=\\\":point_right:\\\" title=\\\":point_right:\\\">|<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-create-local-variables-with-let/18415\\\">Let Bindings</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Clojure   Looprecur\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/clojure/clojure---looprecur/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/clojure/clojure---looprecur/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-clojure-clojure-looprecur.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-clojure-clojure-looprecur.json\n// module chunks = 2029"],"sourceRoot":""}