webpackJsonp([1556],{"./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-interfaces.json":function(e,t){e.exports={data:{markdownRemark:{html:'<h1>Java Interfaces</h1>\n<p>Interface in Java is a bit like the Class, but with a significant difference : an <code>interface</code> can <em>only</em> have method signatures and fields. That means, an Interface cannot contain the implementation of any method, just its signature, i.e. the name, parameters and exceptions of the method. For example :</p>\n<pre><code>public interface Vehicle {\n    public String licensePlate = "";\n    public void start();\n    public void stop();\n}\n</code></pre>\n<p>The interface above contains one field and two methods. Alone, it is not of much use, but they are usually used along with Classes. How? Simple, you have to make sure some class <code>implements</code> it.</p>\n<pre><code>public class Car implements Vehicle {\n    public void start() {\n        System.out.println("starting engine...");\n    }\n    public void stop() {\n        System.out.println("stopping engine...");\n    }\n}\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CItd/0">Run Code</a></p>\n<p>Now, there is a <strong>ground rule</strong> : The Class must implement <strong>all</strong> of the methods in the Interface. The methods must have <em>the exact same</em> signature (name, parameters and exceptions) as described in the interface. The class <em>does not</em> need to declare the fields though, only the methods.</p>\n<h2>Instances of an Interface</h2>\n<p>Once you create a Java Class which <code>implements</code> any Interface, the object instance can be referenced as an instance of the Interface. Similar concept as of Inheritance instantiation.</p>\n<pre><code>// following our previous example\n\nVehicle tesla = new Car();\n\ntesla.start(); // starting engine ...\n</code></pre>\n<p>But, you <strong>cannot</strong> create an instance of an Interface itself. You must create instance of some class implementing an Interface to reference it. Think of interfaces as a blank contract form, or a template.</p>\n<p>What can you do with this feature? Polymorphism! You can use only interfaces to refer to object instances!</p>\n<pre><code>class Truck implements Vehicle {\n    public void start() {\n        System.out.println("starting truck engine...");\n    }\n    public void stop() {\n        System.out.println("stopping truck engine...");\n    }\n}\n\nclass Starter {\n    // static method, can be called without instantiating the class\n    public static void startEngine(Vehicle vehicle) {\n        vehicle.start();\n    }\n}\n\nVehicle tesla = new Car();\nVehicle tata = new Truck();\n\nStarter.startEngine(tesla); // starting engine ...\nStarter.startEngine(tata); // starting truck engine ...\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CItm/0">Run Code</a></p>\n<h2>But how about multiple interfaces?</h2>\n<p>Yes, you can implement multiple Interfaces in a single class. While in <a href="//forum.freecodecamp.com/t/java-docs-inheritance">Inheritance</a> within Classes you were restricted to inherit only one class, here you can extend any number of interfaces. But do not forget to implement <em>all</em> of the methods of all the Interfaces, otherwise compilation will fail!</p>\n<pre><code>public interface GPS {\n    public void getCoordinates();\n}\n\npublic interface Radio {\n    public void startRadio();\n    public void stopRadio();\n}\n\npublic class Smartphone implements GPS,Radio {\n    public void getCoordinates() {\n        // return some coordinates\n    }\n    public void startRadio() {\n      // start Radio\n    }\n    public void stopRadio() {\n        // stop Radio\n    }\n}\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CIto/0">Run Code</a></p>\n<h2>Some features of Interfaces</h2>\n<ul>\n<li>You can place variables within an Interface, although it won\'t be a sensible decision as Classes are not bound to have the same variable. In short, avoid placing variables!</li>\n<li>All variables and methods in an Interface are public, even if you leave out the <code>public</code> keyword.</li>\n<li>An Interface cannot specify the implementation of a particular method. Its upto the Classes to do it. Although there has been a recent exception (see below).</li>\n<li>If a Class implements multiple Interfaces, then there is a remote chance of method signature overlap. Since Java does not allow multiple methods of the exact same signature, this can lead to problems. See <a href="http://stackoverflow.com/questions/2598009/method-name-collision-in-interface-implementation-java">this question</a> for more info.</li>\n</ul>\n<h2>Interface Default Methods</h2>\n<p>Before Java 8, we had no way to direct an Interface to have a particular method implementation. This lead to lot of confusion and code breaks if an Interface definition is suddenly changed.</p>\n<p>Suppose, you wrote an open source library, which contains an Interface. Say, your clients, i.e. practically all developers around the world, are using it heavily and are happy. Now you have had to upgrade the library by adding a new method definition to the Interface to support a new feature. But that would break <em>all</em> builds since all Classes implementing that Interface has to change now. What a catastrophe!</p>\n<p>Thankfully, Java 8 now provides us <code>default</code> methods of Interfaces. A <code>default</code> method <em>can</em> contain its own implementation <em>directly</em> within the Interface! So, if a Class does not implement a default method, the compiler will take the implementation mentioned within the Interface. Nice, isn\'t it? So in your library, you may add any number of default methods in interfaces without the fear of breaking anything!</p>\n<pre><code>public interface GPS {\n    public void getCoordinates();\n    default public void getRoughCoordinates() {\n        // implementation to return coordinates from rough sources\n        // such as wifi &#x26; mobile\n        System.out.println("Fetching rough coordinates...");\n    }\n}\n\npublic interface Radio {\n    public void startRadio();\n    public void stopRadio();\n}\n\npublic class Smartphone implements GPS,Radio {\n    public void getCoordinates() {\n        // return some coordinates\n    }\n    public void startRadio() {\n      // start Radio\n    }\n    public void stopRadio() {\n        // stop Radio\n    }\n\n    // no implementation of getRoughCoordinates()\n}\n\nSmartphone motoG = new Smartphone();\nmotog.getRoughCoordinates(); // Fetching rough coordinates...\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CItp/0">Run Code</a></p>\n<h3>But, what happens if two interfaces have the same method signature?</h3>\n<p>Awesome question. In that case, if you do not provide the implementation in the Class, poor compiler will get confused and simply fail! You have to provide a default method implemention within the Class also. There is also a nifty way using <code>super</code> to call which implementation you like :</p>\n<pre><code>public interface Radio {\n    // public void startRadio();\n    // public void stopRadio();\n\n    default public void next() {\n        System.out.println("Next from Radio");\n    }\n}\n\npublic interface MusicPlayer {\n    // public void start();\n    // public void pause();\n    // public void stop();\n\n    default public void next() {\n        System.out.println("Next from MusicPlayer");\n    }\n}\n\npublic class Smartphone implements Radio, MusicPlayer {\n    public void next() {\n        // Suppose you want to call MusicPlayer next\n        MusicPlayer.super.next();\n    }\n}\n\nSmartphone motoG = new Smartphone();\nmotoG.next(); // Next from MusicPlayer\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CIts/0">Run Code</a></p>\n<h2>Inheriting an Interface</h2>\n<p>It is also possible in Java for an Interface to <em>inherit</em> another Interface, by using, you guessed it, <code>extends</code> keyword :</p>\n<pre><code>public interface Player {\n    public void start();\n    public void pause();\n    public void stop();\n}\n\npublic interface MusicPlayer extends Player {\n    default public void next() {\n        System.out.println("Next from MusicPlayer");\n    }\n}\n</code></pre>\n<p>That means, the Class implementing <code>MusicPlayer</code> Interface has to implement <em>all</em> methods of <code>MusicPlayer</code> as well as <code>Player</code> :</p>\n<pre><code>public class SmartPhone implements MusicPlayer {\n    public void start() {\n        System.out.println("start");\n    }\n    public void stop() {\n        System.out.println("stop");\n    }\n    public void pause() {\n        System.out.println("pause");\n    }\n}\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CIty/0">Run Code</a></p>\n<p>Whoops, did I forget <code>next()</code> ? See, since it was a <code>default</code> method, I didn\'t had to provide an implementation at all. (Wont work for JDK &#x3C; 8)</p>\n<p>So, now you have a good grasp of Interfaces! Go learn about Abstract Classes to know how Java gives you yet another way to define contracts.</p>',frontmatter:{title:"Java Docs Interfaces",parent:"/home/stuart/guides/src/pages/articles/java/java-docs-interfaces/index.md absPath of file"}}},pathContext:{slug:"/articles/java/java-docs-interfaces/"}}}});
//# sourceMappingURL=path---articles-java-java-docs-interfaces-f2ddcac5e47247a94b27.js.map