{"version":3,"sources":["webpack:///path---articles-python-python-integers-23ce18dd133c8ec590f6.js","webpack:///./.cache/json/articles-python-python-integers.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-python-python-integers.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,MAERC,yFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,syKACAC,aACAC,MAAA,kBACAC,OAAA,4FAIAC,aACAC,KAAA","file":"path---articles-python-python-integers-23ce18dd133c8ec590f6.js","sourcesContent":["webpackJsonp([179],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-python-python-integers.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>The theoretical domain for integers in python is negative infinity to infinity. In practice, integer values are limited by the amount of available memory.</p>\\n<p>In Python 2, there was a distinction between <strong><code>int</code></strong>, numbers that fit in a 32 or 64 bit <em>C long</em>, and <strong><code>long</code></strong>, numbers limited by available memory. Python 3 unified the two types into just <strong><code>int</code></strong>, more info in <a href=\\\"https://www.python.org/dev/peps/pep-0237/\\\">PEP 237</a>.</p>\\n<p><strong><code>int</code> creation using integer literals</strong></p>\\n<p><a href=\\\"https://docs.python.org/3/reference/lexical_analysis.html#integer-literals\\\">Integer Literals</a></p>\\n<p><em>Integer objects</em> can be created using using integer literals. Unadorned numbers without decimals are integer literals:</p>\\n<pre><code>>>> 1234567890           # Unadorned numbers are integer literals\\n1234567890\\n>>> type(1234567890)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>Numeric literals do not contain a sign, however creating negative <em>integer objects</em> is possible by prefixing with a unary <code>-</code> (minus) operator with no space before the literal:</p>\\n<pre><code>>>> -1234567890\\n-1234567890\\n>>> type(-1234567890)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>Likewise, positive integer objects can be created by prefixing a unary <code>+</code> (plus) operator with no space before the digits. Usually <code>+</code> is ommited:</p>\\n<pre><code>>>> +1234\\n1234\\n</code></pre>\\n<p>Binary (base 2, prefix: <code>0b</code> or <code>0B</code>), octal (base 8, prefix: <code>0o</code> or <code>0O</code>), and hexadecimal (base 16, prefix: <code>0x</code> or <code>0X</code>) integers can also be created using integer literals:</p>\\n<pre><code>>>> 0b1, 0b10, 0b11\\n(1, 2, 3)\\n>>> 0o1, 0o10, 0o11\\n(1, 8, 9)\\n>>> 0x1, 0x10, 0x11\\n(1, 16, 17)\\n</code></pre>\\n<p>Note that leading 0's for non-zero integer literals are <strong>not allowed</strong>:</p>\\n<pre><code>>>> 0     # Zero by itself is okay.\\n0\\n>>> 01    # Leading zero(s) cause SyntaxError.\\n  File \\\"&#x3C;stdin>\\\", line 1\\n    01\\n     ^\\nSyntaxError: invalid token\\n</code></pre>\\n<p>The <code>int</code> <a href=\\\"https://docs.python.org/3/library/functions.html#int\\\">constructor</a> is another way to create <em>integer objects</em>.</p>\\n<pre><code>class int(x=0)\\nclass int(x, base=10)\\n</code></pre>\\n<p>Creating <em>integer objects</em> with integer literals is preferred when possible:</p>\\n<pre><code>>>> a = 1         # Prefer integer literal when possible.\\n>>> type(a)\\n&#x3C;class 'int'>\\n>>> b = int(1)    # Works but unnecessary.\\n>>> type(b)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>However, the constructor allows for creating <em>integer objects</em> from other number types:</p>\\n<pre><code>>>> a = 1.123\\n>>> type(a)\\n&#x3C;class 'float'>\\n>>> print(a)\\n1.123\\n>>> b = int(1.123)\\n>>> type(b)\\n&#x3C;class 'int'>\\n>>> print(b)\\n1\\n</code></pre>\\n<p>Using the <code>int</code> constructor for floating point numbers will truncate the number towards zero:</p>\\n<pre><code>>>> int(-1.23)\\n-1\\n>>> int(1.23)\\n1\\n</code></pre>\\n<p>The built-in <code>boolean</code> constants are instances of the <code>bool</code> class, and are subclasses of the <code>int</code> class, making them a kind of numeric type:</p>\\n<pre><code>>>> type(True)\\n&#x3C;class 'bool'>\\n>>> issubclass(bool, int)\\nTrue\\n</code></pre>\\n<p>If that doesn't make sense to you, don't worry. For now just remember that calling the int constructor with <code>boolean</code> objects will return <em>integer objects</em>:</p>\\n<pre><code>>>> int(True)\\n1\\n>>> int(False)\\n0\\n</code></pre>\\n<p>The <code>int</code> constructor will also make <em>integer objects</em> from strings:</p>\\n<pre><code>>>> a = \\\"10\\\"\\n>>> type(a)\\n&#x3C;class 'str'>\\n>>> b = int(\\\"10\\\")\\n>>> type(b)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p><em>Strings</em> for the <code>int</code> constructor must represent an integer literal:</p>\\n<p>The second parameter of the <code>int</code> constructor is to specify a base (default: 10). Valid bases are 0 and 2-36.</p>\\n<p>If an explicit base is provided the first argument must be a string.</p>\\n<pre><code>>>> int(\\\"111\\\", 2)\\n7\\n>>> int(111, 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nTypeError: int() can't convert non-string with explicit base\\n</code></pre>\\n<p>The string used for the <code>int</code> constructor with an explicit base must be a valid integer literal for that base:</p>\\n<pre><code>>>> int('11', 2)\\n3\\n>>> int('12', 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nValueError: invalid literal for int() with base 2: '12'\\n</code></pre>\\n<p>Both prefixed and non-prefixed strings of integer literals can be used, however, if used, the prefix must match the provided base.</p>\\n<pre><code>>>> int('1101', 2)\\n13\\n>>> int('0b1101', 2)\\n13\\n>>> int('0x1101', 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nValueError: invalid literal for int() with base 2: '0x1101'\\n</code></pre>\\n<p>If a prefixed string and base 0 is used, the created integer object will use the base specified by the prefix. If no prefix is used, then the base is assumed 10</p>\\n<pre><code>>>> int('100', 0)\\n100\\n>>> int('0b100', 0)\\n4\\n>>> int('0o100', 0)\\n64\\n</code></pre>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Python Integers\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/python/python-integers/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/python/python-integers/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-python-python-integers-23ce18dd133c8ec590f6.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>The theoretical domain for integers in python is negative infinity to infinity. In practice, integer values are limited by the amount of available memory.</p>\\n<p>In Python 2, there was a distinction between <strong><code>int</code></strong>, numbers that fit in a 32 or 64 bit <em>C long</em>, and <strong><code>long</code></strong>, numbers limited by available memory. Python 3 unified the two types into just <strong><code>int</code></strong>, more info in <a href=\\\"https://www.python.org/dev/peps/pep-0237/\\\">PEP 237</a>.</p>\\n<p><strong><code>int</code> creation using integer literals</strong></p>\\n<p><a href=\\\"https://docs.python.org/3/reference/lexical_analysis.html#integer-literals\\\">Integer Literals</a></p>\\n<p><em>Integer objects</em> can be created using using integer literals. Unadorned numbers without decimals are integer literals:</p>\\n<pre><code>>>> 1234567890           # Unadorned numbers are integer literals\\n1234567890\\n>>> type(1234567890)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>Numeric literals do not contain a sign, however creating negative <em>integer objects</em> is possible by prefixing with a unary <code>-</code> (minus) operator with no space before the literal:</p>\\n<pre><code>>>> -1234567890\\n-1234567890\\n>>> type(-1234567890)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>Likewise, positive integer objects can be created by prefixing a unary <code>+</code> (plus) operator with no space before the digits. Usually <code>+</code> is ommited:</p>\\n<pre><code>>>> +1234\\n1234\\n</code></pre>\\n<p>Binary (base 2, prefix: <code>0b</code> or <code>0B</code>), octal (base 8, prefix: <code>0o</code> or <code>0O</code>), and hexadecimal (base 16, prefix: <code>0x</code> or <code>0X</code>) integers can also be created using integer literals:</p>\\n<pre><code>>>> 0b1, 0b10, 0b11\\n(1, 2, 3)\\n>>> 0o1, 0o10, 0o11\\n(1, 8, 9)\\n>>> 0x1, 0x10, 0x11\\n(1, 16, 17)\\n</code></pre>\\n<p>Note that leading 0's for non-zero integer literals are <strong>not allowed</strong>:</p>\\n<pre><code>>>> 0     # Zero by itself is okay.\\n0\\n>>> 01    # Leading zero(s) cause SyntaxError.\\n  File \\\"&#x3C;stdin>\\\", line 1\\n    01\\n     ^\\nSyntaxError: invalid token\\n</code></pre>\\n<p>The <code>int</code> <a href=\\\"https://docs.python.org/3/library/functions.html#int\\\">constructor</a> is another way to create <em>integer objects</em>.</p>\\n<pre><code>class int(x=0)\\nclass int(x, base=10)\\n</code></pre>\\n<p>Creating <em>integer objects</em> with integer literals is preferred when possible:</p>\\n<pre><code>>>> a = 1         # Prefer integer literal when possible.\\n>>> type(a)\\n&#x3C;class 'int'>\\n>>> b = int(1)    # Works but unnecessary.\\n>>> type(b)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p>However, the constructor allows for creating <em>integer objects</em> from other number types:</p>\\n<pre><code>>>> a = 1.123\\n>>> type(a)\\n&#x3C;class 'float'>\\n>>> print(a)\\n1.123\\n>>> b = int(1.123)\\n>>> type(b)\\n&#x3C;class 'int'>\\n>>> print(b)\\n1\\n</code></pre>\\n<p>Using the <code>int</code> constructor for floating point numbers will truncate the number towards zero:</p>\\n<pre><code>>>> int(-1.23)\\n-1\\n>>> int(1.23)\\n1\\n</code></pre>\\n<p>The built-in <code>boolean</code> constants are instances of the <code>bool</code> class, and are subclasses of the <code>int</code> class, making them a kind of numeric type:</p>\\n<pre><code>>>> type(True)\\n&#x3C;class 'bool'>\\n>>> issubclass(bool, int)\\nTrue\\n</code></pre>\\n<p>If that doesn't make sense to you, don't worry. For now just remember that calling the int constructor with <code>boolean</code> objects will return <em>integer objects</em>:</p>\\n<pre><code>>>> int(True)\\n1\\n>>> int(False)\\n0\\n</code></pre>\\n<p>The <code>int</code> constructor will also make <em>integer objects</em> from strings:</p>\\n<pre><code>>>> a = \\\"10\\\"\\n>>> type(a)\\n&#x3C;class 'str'>\\n>>> b = int(\\\"10\\\")\\n>>> type(b)\\n&#x3C;class 'int'>\\n</code></pre>\\n<p><em>Strings</em> for the <code>int</code> constructor must represent an integer literal:</p>\\n<p>The second parameter of the <code>int</code> constructor is to specify a base (default: 10). Valid bases are 0 and 2-36.</p>\\n<p>If an explicit base is provided the first argument must be a string.</p>\\n<pre><code>>>> int(\\\"111\\\", 2)\\n7\\n>>> int(111, 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nTypeError: int() can't convert non-string with explicit base\\n</code></pre>\\n<p>The string used for the <code>int</code> constructor with an explicit base must be a valid integer literal for that base:</p>\\n<pre><code>>>> int('11', 2)\\n3\\n>>> int('12', 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nValueError: invalid literal for int() with base 2: '12'\\n</code></pre>\\n<p>Both prefixed and non-prefixed strings of integer literals can be used, however, if used, the prefix must match the provided base.</p>\\n<pre><code>>>> int('1101', 2)\\n13\\n>>> int('0b1101', 2)\\n13\\n>>> int('0x1101', 2)\\nTraceback (most recent call last):\\n  File \\\"&#x3C;stdin>\\\", line 1, in &#x3C;module>\\nValueError: invalid literal for int() with base 2: '0x1101'\\n</code></pre>\\n<p>If a prefixed string and base 0 is used, the created integer object will use the base specified by the prefix. If no prefix is used, then the base is assumed 10</p>\\n<pre><code>>>> int('100', 0)\\n100\\n>>> int('0b100', 0)\\n4\\n>>> int('0o100', 0)\\n64\\n</code></pre>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Python Integers\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/python/python-integers/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/python/python-integers/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-python-python-integers.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-python-python-integers.json\n// module chunks = 179"],"sourceRoot":""}