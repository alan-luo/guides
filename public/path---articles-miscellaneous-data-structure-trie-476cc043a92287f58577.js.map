{"version":3,"sources":["webpack:///path---articles-miscellaneous-data-structure-trie-476cc043a92287f58577.js","webpack:///./.cache/json/articles-miscellaneous-data-structure-trie.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-trie.json","module","exports","data","markdownRemark","html","frontmatter","title","parent","pathContext","slug"],"mappings":"AAAAA,cAAc,MAERC,oGACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,gBACAC,KAAA,+uLACAC,aACAC,MAAA,sBACAC,OAAA,uGAIAC,aACAC,KAAA","file":"path---articles-miscellaneous-data-structure-trie-476cc043a92287f58577.js","sourcesContent":["webpackJsonp([409],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-trie.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<h2>Introduction to Trie</h2>\\n<p>The word trie is an inflix of the word \\\"re<strong>trie</strong>val\\\", because the trie can find a single word in a dictionary with only a prefix of the word.<br>\\nTrie is an efficient data retrieval data structure, using trie, search complexities can be brought to an optimal limit, i.e. length of the string.<br>\\nIt is a multi-way tree structure useful for storing strings over an alphabet, when we are storing them.<br>\\nIt has been used to store large dictionaries of English, say, words in spell-checking programs.<br>\\nHowever, the penalty on tries is the storage requirement.</p>\\n<h2>What is a trie?</h2>\\n<p>A trie is a tree like data structure which stores strings, and helps you find the data associated with that string using the prefix of the string.<br>\\nFor example, say you plan on building a dictionary to store strings along with their meanings. You must be wondering why can't I simply use a hash table, to get the information.<br>\\nYes, you obviously can get information using a hash table, but, the <a>hash tables</a> can only find data where the string exactly matches the one we've added. But trie will give us the capability to find strings with common prefixes, a missing character etc in lesser time, in comparison to a hash table.<br>\\nA trie typically, looks something like this,</p>\\n<p><img src=\\\"//discourse-user-assets.s3.amazonaws.com/original/2X/c/c43e222a6f9152512d73f97b8117db5c074bbc8e.png\\\" alt=\\\"Trie\\\"></p>\\n<p>This is an image of a Trie, which stores the words {assoc, algo, all, also, tree, trie}.</p>\\n<h2>How to implement a trie?</h2>\\n<p>Let's implement a trie in python, for storing words with their meanings from english dictionary.</p>\\n<pre><code>ALPHABET_SIZE = 26 # For English\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = [None]*(ALPHABET_SIZE) # Each index respective to each character.\\n        self.meaning = None # Meaning of the word.\\n        self.ends_here = False # Tells us if the word ends here.\\n</code></pre>\\n<p>As you can see, edges are 26 in length, each index referring to each character in the alphabet. 'A' corresponding to 0, 'B' to 1, 'C' to 2 ... 'Z' to 25th index. If the character you are looking for is pointing to <code>None</code>, that implies the word is not there in the trie.</p>\\n<p>A typical Trie should implement at least these two functions:</p>\\n<ul>\\n<li><code>add_word(word,meaning)</code></li>\\n<li><code>search_word(word)</code></li>\\n<li><code>delete_word(word)</code></li>\\n</ul>\\n<p>Additionally, one can also add something like</p>\\n<ul>\\n<li><code>get_all_words()</code></li>\\n<li><code>get_all_words_with_prefix(prefix)</code></li>\\n</ul>\\n<h4>Adding Word to the trie</h4>\\n<pre><code>    def add_word(self,word,meaning):\\n        if len(word)==0:\\n            self.ends_here = True # Because we have reached the end of the word\\n            self.meaning = meaning # Adding the meaning to that node\\n            return\\n        ch = word[0] # First character\\n        # ASCII value of the first character (minus) the ASCII value of 'a'-> the first character of our ALPHABET gives us the index of the edge we have to look up.\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            # This implies that there's no prefix with this character yet.\\n            new_node = TrieNode()\\n            self.edges[index] = new_node\\n\\n        self.edges[index].add(word[1:],meaning) #Adding the remaining word\\n</code></pre>\\n<h4>Retrieving data</h4>\\n<pre><code>    def search_word(self,word):\\n        if len(word)==0:\\n            if self.ends_here:\\n                return True\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch)-ord('a')\\n        if self.edge[index]== None:\\n            return False\\n        else:\\n            return self.edge[index].search_word(word[1:])\\n</code></pre>\\n<p>The <code>search_word</code> function will tell us if the word exists in the Trie or not. Since ours is a dictionary, we need to fetch the meaning as well, now lets declare a function to do that.</p>\\n<pre><code>    def get_meaning(self,word):\\n        if len(word)==0 :\\n            if self.ends_here:\\n                return self.meaning\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            return \\\"Word doesn't exist in the Trie\\\"\\n        else:\\n            return self.edges[index].get_meaning(word[1:])\\n</code></pre>\\n<h4>Deleting data</h4>\\n<p>By deleting data, you just need to change the variable <code>ends_here</code> to <code>False</code>. Doing that doesn't alter the prefixes, but stills deletes the meaning and the existence of the word from the trie.</p>\\n<pre><code>    def delete_word(self,word):\\n        if len(word)==0:\\n            if self.ends_here:\\n                self.ends_here = False\\n                self.meaning = None\\n                return \\\"Deleted\\\"\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            return \\\"Word doesn't exist in the Trie\\\"\\n        else:\\n            return self.edges[index].delete_word(word[1:])\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CWbr\\\">Run Code</a></p>\\n<h2>Resources</h2>\\n<ul>\\n<li>For further reading, you can try this <a href=\\\"https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/\\\">topcoder</a> tutorial.</li>\\n<li>Also, a tutorial from <a href=\\\"http://www.geeksforgeeks.org/trie-insert-and-search/\\\">geeksforgeeks</a></li>\\n</ul>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Data Structure Trie\",\n\t\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/data-structure-trie/index.md absPath of file\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/articles/miscellaneous/data-structure-trie/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---articles-miscellaneous-data-structure-trie-476cc043a92287f58577.js","module.exports = {\n\t\"data\": {\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<h2>Introduction to Trie</h2>\\n<p>The word trie is an inflix of the word \\\"re<strong>trie</strong>val\\\", because the trie can find a single word in a dictionary with only a prefix of the word.<br>\\nTrie is an efficient data retrieval data structure, using trie, search complexities can be brought to an optimal limit, i.e. length of the string.<br>\\nIt is a multi-way tree structure useful for storing strings over an alphabet, when we are storing them.<br>\\nIt has been used to store large dictionaries of English, say, words in spell-checking programs.<br>\\nHowever, the penalty on tries is the storage requirement.</p>\\n<h2>What is a trie?</h2>\\n<p>A trie is a tree like data structure which stores strings, and helps you find the data associated with that string using the prefix of the string.<br>\\nFor example, say you plan on building a dictionary to store strings along with their meanings. You must be wondering why can't I simply use a hash table, to get the information.<br>\\nYes, you obviously can get information using a hash table, but, the <a>hash tables</a> can only find data where the string exactly matches the one we've added. But trie will give us the capability to find strings with common prefixes, a missing character etc in lesser time, in comparison to a hash table.<br>\\nA trie typically, looks something like this,</p>\\n<p><img src=\\\"//discourse-user-assets.s3.amazonaws.com/original/2X/c/c43e222a6f9152512d73f97b8117db5c074bbc8e.png\\\" alt=\\\"Trie\\\"></p>\\n<p>This is an image of a Trie, which stores the words {assoc, algo, all, also, tree, trie}.</p>\\n<h2>How to implement a trie?</h2>\\n<p>Let's implement a trie in python, for storing words with their meanings from english dictionary.</p>\\n<pre><code>ALPHABET_SIZE = 26 # For English\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = [None]*(ALPHABET_SIZE) # Each index respective to each character.\\n        self.meaning = None # Meaning of the word.\\n        self.ends_here = False # Tells us if the word ends here.\\n</code></pre>\\n<p>As you can see, edges are 26 in length, each index referring to each character in the alphabet. 'A' corresponding to 0, 'B' to 1, 'C' to 2 ... 'Z' to 25th index. If the character you are looking for is pointing to <code>None</code>, that implies the word is not there in the trie.</p>\\n<p>A typical Trie should implement at least these two functions:</p>\\n<ul>\\n<li><code>add_word(word,meaning)</code></li>\\n<li><code>search_word(word)</code></li>\\n<li><code>delete_word(word)</code></li>\\n</ul>\\n<p>Additionally, one can also add something like</p>\\n<ul>\\n<li><code>get_all_words()</code></li>\\n<li><code>get_all_words_with_prefix(prefix)</code></li>\\n</ul>\\n<h4>Adding Word to the trie</h4>\\n<pre><code>    def add_word(self,word,meaning):\\n        if len(word)==0:\\n            self.ends_here = True # Because we have reached the end of the word\\n            self.meaning = meaning # Adding the meaning to that node\\n            return\\n        ch = word[0] # First character\\n        # ASCII value of the first character (minus) the ASCII value of 'a'-> the first character of our ALPHABET gives us the index of the edge we have to look up.\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            # This implies that there's no prefix with this character yet.\\n            new_node = TrieNode()\\n            self.edges[index] = new_node\\n\\n        self.edges[index].add(word[1:],meaning) #Adding the remaining word\\n</code></pre>\\n<h4>Retrieving data</h4>\\n<pre><code>    def search_word(self,word):\\n        if len(word)==0:\\n            if self.ends_here:\\n                return True\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch)-ord('a')\\n        if self.edge[index]== None:\\n            return False\\n        else:\\n            return self.edge[index].search_word(word[1:])\\n</code></pre>\\n<p>The <code>search_word</code> function will tell us if the word exists in the Trie or not. Since ours is a dictionary, we need to fetch the meaning as well, now lets declare a function to do that.</p>\\n<pre><code>    def get_meaning(self,word):\\n        if len(word)==0 :\\n            if self.ends_here:\\n                return self.meaning\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            return \\\"Word doesn't exist in the Trie\\\"\\n        else:\\n            return self.edges[index].get_meaning(word[1:])\\n</code></pre>\\n<h4>Deleting data</h4>\\n<p>By deleting data, you just need to change the variable <code>ends_here</code> to <code>False</code>. Doing that doesn't alter the prefixes, but stills deletes the meaning and the existence of the word from the trie.</p>\\n<pre><code>    def delete_word(self,word):\\n        if len(word)==0:\\n            if self.ends_here:\\n                self.ends_here = False\\n                self.meaning = None\\n                return \\\"Deleted\\\"\\n            else:\\n                return \\\"Word doesn't exist in the Trie\\\"\\n        ch = word[0]\\n        index = ord(ch) - ord('a')\\n        if self.edges[index] == None:\\n            return \\\"Word doesn't exist in the Trie\\\"\\n        else:\\n            return self.edges[index].delete_word(word[1:])\\n</code></pre>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" alt=\\\":rocket:\\\" title=\\\":rocket:\\\"> <a href=\\\"https://repl.it/CWbr\\\">Run Code</a></p>\\n<h2>Resources</h2>\\n<ul>\\n<li>For further reading, you can try this <a href=\\\"https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/\\\">topcoder</a> tutorial.</li>\\n<li>Also, a tutorial from <a href=\\\"http://www.geeksforgeeks.org/trie-insert-and-search/\\\">geeksforgeeks</a></li>\\n</ul>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Data Structure Trie\",\n\t\t\t\t\"parent\": \"/home/stuart/guides/src/pages/articles/miscellaneous/data-structure-trie/index.md absPath of file\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/articles/miscellaneous/data-structure-trie/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/articles-miscellaneous-data-structure-trie.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/articles-miscellaneous-data-structure-trie.json\n// module chunks = 409"],"sourceRoot":""}