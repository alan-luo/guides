webpackJsonp([1336],{"./node_modules/json-loader/index.js!./.cache/json/articles-java-java-docs-inheritance.json":function(e,t){e.exports={data:{markdownRemark:{html:'<h1>Java Inheritance</h1>\n<p>Java inheritance refers to the ability of a Java Class to <code>inherit</code> the properties from some other Class. Think of it like a child inheriting properties from its parents, the concept is very similar to that. In Java lingo, it is also called <em>extend</em>-ing a class. Some simple things to remember :</p>\n<ul>\n<li>The Class that extends or inherits is called <strong>subclass</strong></li>\n<li>The Class that is being extended or inherited is called <strong>superclass</strong></li>\n</ul>\n<p>Thus, inheritance gives Java the cool capability of <em>re-using</em> code, or share code between classes!</p>\n<p>Let\'s describe it with the classic example of a <code>Vehicle</code> class and a <code>Car</code> class :</p>\n<pre><code>public class Vehicle {\n    public void start() {\n        // starting the engine\n    }\n\n    public void stop() {\n        // stopping the engine\n    }\n}\n\npublic class Car extends Vehicle {\n    int numberOfSeats = 4;\n\n    public int getNumberOfSeats() {\n        return numberOfSeats;\n    }\n}\n</code></pre>\n<p>Here we can see the <code>Car</code> class inheriting the properties of the <code>Vehicle</code> class. So, we dont have to write the same code of <code>start()</code> and <code>stop()</code> for <code>Car</code> as well, as those properties come from its parent. Yes, objects created from the <code>Car</code> class <em>also</em> have those properties!</p>\n<pre><code>Car tesla = new Car();\n\ntesla.start();\n\ntesla.stop();\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJXz/0">Run Code</a></p>\n<p>But, does the parent Class has the methods of the child? No, it doesn\'t.</p>\n<p>Therefore, whenever you need to share some common bit of code to some more classes, it is always good to have a parent Class, and then extend that Class whenever needed! Saves a lot of lines of code, makes code modular and better testable.</p>\n<h2>What can be inherited ?</h2>\n<ul>\n<li>All <code>protected</code> and <code>public</code> fields and methods from parent</li>\n</ul>\n<h2>What cannot be inherited ?</h2>\n<ul>\n<li><code>private</code> fields and methods</li>\n<li>Constructors. Although, subclass constructor <em>has</em> to call superclass constructor if its defined (More on that later!)</li>\n<li>Multiple classes. Java supports only <strong>single inheritance</strong>, that is you can only inherit one class at a time.</li>\n<li>Fields. Individual fields of a class cannot be overriden by the subclass.</li>\n</ul>\n<h2>Type Casting &#x26; Reference</h2>\n<p>In Java, it is possible to reference a subclass as an <em>instance</em> of its superclass. It is called <em>Polymorphism</em> in Object Oriented Programming, the ability of an object to take on many forms. For example, <code>Car</code> class object can be referenced as a <code>Vehicle</code> class instance like this :</p>\n<pre><code>Vehicle car = new Car();\n</code></pre>\n<p>Although, the opposite is not possible :</p>\n<pre><code>Car car = new Vehicle(); // ERROR\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJYB/0">Run Code</a></p>\n<p>Since you can reference a Java subclass as a superclass instance, you can cast a subclass object easily to a superclass instance. It may be possible to cast a superclass object into a subclass type, but <em>only if the object is really an instance of subclass</em>. So keep this in mind :</p>\n<pre><code>Car car = new Car();\nVehicle vehicle = car; // upcasting\nCar car2 = (Car)vechile; //downcasting\n\nBike bike = new Bike(); // say Bike is also a subclass of Vehicle\nVehicle v = bike; // upcasting, no problem here.\nCar car3 = (Car)bike; // Compilation Error : as bike is NOT a instance of Car\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJYM/0">Run Code</a></p>\n<p>Now you know how to share code through parent-child relationship. But, what if, you do not like the implementation of a particular method in the child class and want to write a new one for it? What to do then?</p>\n<h2>Override it!</h2>\n<p>Java lets you <em>override</em> or redefine the methods defined in the superclass. For example, your <code>Car</code> class has a different implementation of <code>start()</code> than the parent <code>Vehicle</code>, so you do this :</p>\n<pre><code>public class Vehicle {\n    public void start() {\n      System.out.println("Vehicle start code");\n    }\n}\n\npublic class Car extends Vehicle {\n    public void start() {\n      System.out.println("Car start code");\n  }\n}\n\nCar car = new Car();\ncar.start(); // "Car start code"\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJYZ/1">Run Code</a></p>\n<p>So, it\'s pretty simple to override methods in the subclass. Although, there is a <em>catch</em>. Only that superclass method will be overriden which has the <em>exact same method signature</em> as the subclass method. That means the subclass method definition must have the exact same name, same number and type of parameters, and in the exact same sequence. Thus, <code>public void start(String key)</code> would not override <code>public void start()</code>.</p>\n<p><strong>Notes</strong> :</p>\n<ul>\n<li>You cannot override private methods of the superclass. (Quite obvious, isn\'t it?)</li>\n<li>What if the method of superclass which you are overriding in the subclass suddenly gets obliterated or methods changed? It would fail in runtime! So Java provides you a nifty annotation <code>@Override</code> which you can place over the subclass method, which will warn the compiler of those incidents!</li>\n</ul>\n<p>Annotations in Java is a good coding practice, but they are not a necessity. The compiler is smart enough to figure out overriding on its own though. Unlike other OOP languages, Annotations in Java it doesn\'t necessarily modify the method or add extra functionality.</p>\n<h2>How to call super class methods?</h2>\n<p>Funny you ask about it! Just use the keyword <code>super</code> :</p>\n<pre><code>public class Vehicle() {\n    public void start() {\n      System.out.println("Vehicle start code");\n    }\n}\n\npublic class Car extends Vehicle {\n    public void run() {\n      super.start();\n  }\n}\n\nCar car = new Car();\ncar.run(); // "Vehicle start code"\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJY4/0">Run Code</a></p>\n<p><strong>N.B.</strong> : Although you can call the parent method by <code>super</code> call, you cannot go up the inheritance with chained <code>super</code> calls.</p>\n<h2>How to know the type of a class?</h2>\n<p>Using the <code>instanceof</code> keyword. Having lots of classes and subclasses it would be a little confusing to know which class is a subclass of which one in runtime. So, we can use <code>instanceof</code> to determine whether a class is actually a subclass of a superclass or not.</p>\n<pre><code>Car car = new Car();\n\nboolean flag = car instanceof Vehicle; // true in this case!\n</code></pre>\n<h2>Constructors &#x26; Inheritance</h2>\n<p>As mentioned earlier, constructors cannot be directly inherited by a subclass. Although, a subclass is <em>required</em> to call its parent\'s constructor as the <a href="http://stackoverflow.com/questions/1168345/why-does-this-and-super-have-to-be-the-first-statement-in-a-constructor">first thing</a> in its own constructor. How? You guessed it, using <code>super</code> :</p>\n<pre><code>public class Vehicle {\n    public Vehicle() {\n        // constructor\n    }\n    public void start() {\n      System.out.println("Vehicle start code");\n    }\n}\n\npublic class Car extends Vehicle {\n    public Car() {\n      super();\n    }\n    public void run() {\n      super.start();\n  }\n}\n</code></pre>\n<p><img src="//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2" alt=":rocket:" title=":rocket:"> <a href="https://repl.it/CJY8/0">Run Code</a></p>\n<p>Remember, if the superclass does not have any constructors defined, you dont have to call it explicitely in the subclass. Java handles that internally for you! Invocation to <code>super</code> constructor is done in the case when the super class is to be called with any other constructor other than the <em>default constructor</em>.</p>\n<p>If no other constructors are defined, then Java invokes the default super class constructor (<em>even if not defined explicitly</em>).</p>\n<p>Congrats, now you know all about Inheritance! Read more about advanced ways to inherit things in Abstract Classes and <a href="//forum.freecodecamp.com/t/java-docs-interfaces">Interfaces</a>!</p>',frontmatter:{title:"Java Docs Inheritance",parent:"/home/stuart/guides/src/pages/articles/java/java-docs-inheritance/index.md absPath of file"}}},pathContext:{slug:"/articles/java/java-docs-inheritance/"}}}});
//# sourceMappingURL=path---articles-java-java-docs-inheritance-5b763dfc3e62bb9be4b4.js.map